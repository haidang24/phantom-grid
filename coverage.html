
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>agent: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">phantom-grid/cmd/agent/main.go (0.0%)</option>
				
				<option value="file1">phantom-grid/cmd/config-gen/main.go (0.0%)</option>
				
				<option value="file2">phantom-grid/cmd/phantom/main.go (0.0%)</option>
				
				<option value="file3">phantom-grid/cmd/spa-client/main.go (0.0%)</option>
				
				<option value="file4">phantom-grid/cmd/spa-keygen/main.go (0.0%)</option>
				
				<option value="file5">phantom-grid/examples/spa-client-example.go (0.0%)</option>
				
				<option value="file6">phantom-grid/internal/agent/agent.go (0.0%)</option>
				
				<option value="file7">phantom-grid/internal/config/config.go (0.0%)</option>
				
				<option value="file8">phantom-grid/internal/config/constants.go (0.0%)</option>
				
				<option value="file9">phantom-grid/internal/config/ports.go (91.7%)</option>
				
				<option value="file10">phantom-grid/internal/config/spa.go (0.0%)</option>
				
				<option value="file11">phantom-grid/internal/dashboard/dashboard.go (0.0%)</option>
				
				<option value="file12">phantom-grid/internal/dashboard/event_loop.go (0.0%)</option>
				
				<option value="file13">phantom-grid/internal/dashboard/widgets.go (0.0%)</option>
				
				<option value="file14">phantom-grid/internal/ebpf/egress_bpfel.go (0.0%)</option>
				
				<option value="file15">phantom-grid/internal/ebpf/loader.go (0.0%)</option>
				
				<option value="file16">phantom-grid/internal/ebpf/phantom_bpfel.go (0.0%)</option>
				
				<option value="file17">phantom-grid/internal/exporter/elk.go (0.0%)</option>
				
				<option value="file18">phantom-grid/internal/honeypot/filesystem.go (0.0%)</option>
				
				<option value="file19">phantom-grid/internal/honeypot/handler.go (0.0%)</option>
				
				<option value="file20">phantom-grid/internal/honeypot/handlers.go (0.0%)</option>
				
				<option value="file21">phantom-grid/internal/honeypot/honeypot.go (0.0%)</option>
				
				<option value="file22">phantom-grid/internal/honeypot/http_handler.go (0.0%)</option>
				
				<option value="file23">phantom-grid/internal/honeypot/mysql_handler.go (0.0%)</option>
				
				<option value="file24">phantom-grid/internal/honeypot/redis_handler.go (0.0%)</option>
				
				<option value="file25">phantom-grid/internal/honeypot/ssh_handler.go (0.0%)</option>
				
				<option value="file26">phantom-grid/internal/logger/event.go (0.0%)</option>
				
				<option value="file27">phantom-grid/internal/logger/logger.go (66.7%)</option>
				
				<option value="file28">phantom-grid/internal/logger/manager.go (0.0%)</option>
				
				<option value="file29">phantom-grid/internal/mirage/banners.go (0.0%)</option>
				
				<option value="file30">phantom-grid/internal/network/interface.go (0.0%)</option>
				
				<option value="file31">phantom-grid/internal/spa/handler.go (76.0%)</option>
				
				<option value="file32">phantom-grid/internal/spa/manager.go (0.0%)</option>
				
				<option value="file33">phantom-grid/internal/spa/map_loader.go (9.6%)</option>
				
				<option value="file34">phantom-grid/internal/spa/packet.go (92.6%)</option>
				
				<option value="file35">phantom-grid/internal/spa/totp.go (80.0%)</option>
				
				<option value="file36">phantom-grid/internal/spa/verifier.go (86.7%)</option>
				
				<option value="file37">phantom-grid/internal/spa/wrapper.go (0.0%)</option>
				
				<option value="file38">phantom-grid/pkg/spa/client.go (66.7%)</option>
				
				<option value="file39">phantom-grid/pkg/spa/client_dynamic.go (82.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "bytes"
        "flag"
        "fmt"
        "log"
        "os"
        "strings"

        "phantom-grid/internal/agent"
        "phantom-grid/internal/config"
        "phantom-grid/internal/dashboard"
)

func main() <span class="cov0" title="0">{
        // Custom usage function
        flag.Usage = func() </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Phantom Grid - Kernel-level Active Defense System\n\n")
                fmt.Fprintf(os.Stderr, "Usage: %s [options]\n\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "Options:\n")
                flag.PrintDefaults()
                fmt.Fprintf(os.Stderr, "\nExamples:\n")
                fmt.Fprintf(os.Stderr, "  # Basic usage with auto-detected interface\n")
                fmt.Fprintf(os.Stderr, "  sudo %s\n\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "  # With specific interface\n")
                fmt.Fprintf(os.Stderr, "  sudo %s -interface ens33\n\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "  # With Dynamic Asymmetric SPA\n")
                fmt.Fprintf(os.Stderr, "  sudo %s -interface ens33 -spa-mode asymmetric -spa-key-dir ./keys\n\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "  # With ELK integration\n")
                fmt.Fprintf(os.Stderr, "  sudo %s -interface ens33 -output both -elk-address http://localhost:9200\n\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "See docs/GETTING_STARTED.md for detailed instructions.\n")
        }</span>

        // Parse command line arguments
        <span class="cov0" title="0">interfaceFlag := flag.String("interface", "", "Network interface name (e.g., eth0, ens33). If not specified, auto-detect will be used.")
        outputModeFlag := flag.String("output", "dashboard", "Output mode: 'dashboard', 'elk', or 'both'")
        elkAddressFlag := flag.String("elk-address", "http://localhost:9200", "Elasticsearch address (comma-separated for multiple)")
        elkIndexFlag := flag.String("elk-index", "phantom-grid", "Elasticsearch index name")
        elkUserFlag := flag.String("elk-user", "", "Elasticsearch username (optional)")
        elkPassFlag := flag.String("elk-pass", "", "Elasticsearch password (optional)")
        elkTLSFlag := flag.Bool("elk-tls", false, "Enable TLS for Elasticsearch")
        elkSkipVerifyFlag := flag.Bool("elk-skip-verify", false, "Skip TLS certificate verification")
        
        // SPA Configuration flags
        spaModeFlag := flag.String("spa-mode", "static", "SPA mode: 'static', 'dynamic', or 'asymmetric'")
        spaKeyDirFlag := flag.String("spa-key-dir", "./keys", "Directory containing SPA keys")
        spaTOTPSecretFlag := flag.String("spa-totp-secret", "", "TOTP secret (base64 encoded, 32 bytes). If not provided, auto-loads from keys/totp_secret.txt")
        spaStaticTokenFlag := flag.String("spa-static-token", "", "Static SPA token (for static mode). If not provided, will prompt or use default")
        
        // Help flag
        helpFlag := flag.Bool("h", false, "Show help message")
        helpFlag2 := flag.Bool("help", false, "Show help message")
        
        flag.Parse()
        
        // Show help if requested
        if *helpFlag || *helpFlag2 </span><span class="cov0" title="0">{
                flag.Usage()
                os.Exit(0)
        }</span>

        // Parse output mode
        <span class="cov0" title="0">var outputMode config.OutputMode
        switch strings.ToLower(*outputModeFlag) </span>{
        case "dashboard":<span class="cov0" title="0">
                outputMode = config.OutputModeDashboard</span>
        case "elk":<span class="cov0" title="0">
                outputMode = config.OutputModeELK</span>
        case "both":<span class="cov0" title="0">
                outputMode = config.OutputModeBoth</span>
        default:<span class="cov0" title="0">
                log.Fatalf("[!] Invalid output mode: %s. Use 'dashboard', 'elk', or 'both'", *outputModeFlag)</span>
        }

        // Configure ELK
        <span class="cov0" title="0">elkConfig := config.DefaultELKConfig()
        if outputMode == config.OutputModeELK || outputMode == config.OutputModeBoth </span><span class="cov0" title="0">{
                elkConfig.Enabled = true
                elkConfig.Addresses = strings.Split(*elkAddressFlag, ",")
                for i := range elkConfig.Addresses </span><span class="cov0" title="0">{
                        elkConfig.Addresses[i] = strings.TrimSpace(elkConfig.Addresses[i])
                }</span>
                <span class="cov0" title="0">elkConfig.Index = *elkIndexFlag
                elkConfig.Username = *elkUserFlag
                elkConfig.Password = *elkPassFlag
                elkConfig.UseTLS = *elkTLSFlag
                elkConfig.SkipVerify = *elkSkipVerifyFlag

                log.Printf("[SYSTEM] ELK output enabled: %s (index: %s)", strings.Join(elkConfig.Addresses, ", "), elkConfig.Index)</span>
        }

        // Create dashboard channel (only if dashboard is enabled)
        <span class="cov0" title="0">var dashboardChan chan string
        if outputMode == config.OutputModeDashboard || outputMode == config.OutputModeBoth </span><span class="cov0" title="0">{
                dashboardChan = make(chan string, 1000)
        }</span>

        // Handle static token for static mode
        <span class="cov0" title="0">var staticToken string
        if *spaModeFlag == "static" </span><span class="cov0" title="0">{
                if *spaStaticTokenFlag != "" </span><span class="cov0" title="0">{
                        staticToken = *spaStaticTokenFlag
                        log.Printf("[SPA] Using custom static token (length: %d)", len(staticToken))
                }</span> else<span class="cov0" title="0"> {
                        // Prompt for token if not provided
                        fmt.Print("[SPA] Enter static token (press Enter for default): ")
                        var input string
                        fmt.Scanln(&amp;input)
                        if input != "" </span><span class="cov0" title="0">{
                                staticToken = input
                                log.Printf("[SPA] Using custom static token (length: %d)", len(staticToken))
                        }</span> else<span class="cov0" title="0"> {
                                staticToken = config.SPASecretToken
                                log.Printf("[SPA] Using default static token")
                        }</span>
                }
        }

        // Configure Dynamic SPA
        <span class="cov0" title="0">var spaConfig *config.DynamicSPAConfig
        if *spaModeFlag != "static" </span><span class="cov0" title="0">{
                spaConfig = config.DefaultDynamicSPAConfig()
                
                // Set mode
                switch *spaModeFlag </span>{
                case "dynamic":<span class="cov0" title="0">
                        spaConfig.Mode = config.SPAModeDynamic</span>
                case "asymmetric":<span class="cov0" title="0">
                        spaConfig.Mode = config.SPAModeAsymmetric</span>
                default:<span class="cov0" title="0">
                        log.Fatalf("[!] Invalid SPA mode: %s. Use 'static', 'dynamic', or 'asymmetric'", *spaModeFlag)</span>
                }
                
                // Load keys if asymmetric mode
                <span class="cov0" title="0">if spaConfig.Mode == config.SPAModeAsymmetric </span><span class="cov0" title="0">{
                        publicKeyPath := fmt.Sprintf("%s/spa_public.key", *spaKeyDirFlag)
                        publicKey, _, err := config.LoadKeysFromFile(
                                publicKeyPath,
                                "", // Private key not needed on server
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("[!] Error: Failed to load public key from %s: %v", publicKeyPath, err)
                                log.Printf("[!] Please ensure keys are generated: go run ./cmd/spa-keygen -dir %s", *spaKeyDirFlag)
                                log.Fatalf("[!] Cannot start in asymmetric mode without public key")
                        }</span>
                        <span class="cov0" title="0">spaConfig.PublicKey = publicKey
                        log.Printf("[SPA] Public key loaded from %s", publicKeyPath)</span>
                }
                
                // Load TOTP secret if provided (only if spaConfig is not nil)
                <span class="cov0" title="0">if spaConfig != nil </span><span class="cov0" title="0">{
                        if *spaTOTPSecretFlag != "" </span><span class="cov0" title="0">{
                                totpSecretBytes := []byte(*spaTOTPSecretFlag)
                                // Remove newline and null bytes if present
                                totpSecretBytes = bytes.TrimRight(totpSecretBytes, "\n\r\x00")
                                spaConfig.TOTPSecret = totpSecretBytes
                                log.Printf("[SPA] TOTP secret loaded from command line")
                        }</span> else<span class="cov0" title="0"> {
                                // Try to load from file
                                totpSecretPath := fmt.Sprintf("%s/totp_secret.txt", *spaKeyDirFlag)
                                if totpSecretData, err := os.ReadFile(totpSecretPath); err == nil </span><span class="cov0" title="0">{
                                        // Remove newline and null bytes if present
                                        totpSecretData = bytes.TrimRight(totpSecretData, "\n\r\x00")
                                        spaConfig.TOTPSecret = totpSecretData
                                        log.Printf("[SPA] TOTP secret loaded from file: %s", totpSecretPath)
                                }</span> else<span class="cov0" title="0"> {
                                        log.Printf("[!] Warning: TOTP secret not found at %s, using default (may cause authentication failures)", totpSecretPath)
                                        log.Printf("[!] To fix: Create %s or use -spa-totp-secret flag", totpSecretPath)
                                }</span>
                        }
                }
        }

        // Create and start agent
        <span class="cov0" title="0">agentInstance, err := agent.New(*interfaceFlag, outputMode, elkConfig, dashboardChan, spaConfig, staticToken)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("[!] Failed to initialize agent: %v", err)
        }</span>
        <span class="cov0" title="0">defer agentInstance.Close()

        // Start agent services
        if err := agentInstance.Start(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("[!] Failed to start agent: %v", err)
        }</span>

        // Start dashboard only if enabled
        <span class="cov0" title="0">if outputMode == config.OutputModeDashboard || outputMode == config.OutputModeBoth </span><span class="cov0" title="0">{
                // Get eBPF objects for dashboard
                phantomObjs, egressObjs := agentInstance.GetEBPFObjects()

                // Start dashboard
                dashboardInstance := dashboard.New(
                        agentInstance.GetInterfaceName(),
                        phantomObjs,
                        egressObjs,
                        dashboardChan,
                )
                dashboardInstance.Start()
        }</span> else<span class="cov0" title="0"> {
                // ELK-only mode: wait for interrupt
                log.Printf("[SYSTEM] Running in ELK-only mode. Press Ctrl+C to stop.")
                fmt.Println("[SYSTEM] Logs are being sent to Elasticsearch. No dashboard will be displayed.")
                select </span>{} // Block forever
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "flag"
        "fmt"
        "os"
        "path/filepath"
        "sort"
        "strings"
        "text/template"

        "phantom-grid/internal/config"
)

const ebpfHeaderTemplate = `// AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
// This file is generated from internal/config/config.go and ports.go
// Run 'make generate-config' to regenerate

// Core Ports
#define HONEYPOT_PORT {{.Constants.HoneypotPort}}
#define SSH_PORT {{.Constants.SSHPort}}

// SPA Configuration
#define SPA_MAGIC_PORT {{.Constants.SPAMagicPort}}
#define SPA_SECRET_TOKEN "{{.Constants.SPASecretToken}}"
#define SPA_TOKEN_LEN {{.Constants.SPATokenLen}}
#define SPA_WHITELIST_DURATION_NS ({{.Constants.SPAWhitelistDuration}}ULL * 1000000000ULL) // {{.Constants.SPAWhitelistDuration}} seconds in nanoseconds

// OS Fingerprint Values (TTL)
#define TTL_WINDOWS {{.Constants.TTLWindows}}
#define TTL_LINUX {{.Constants.TTLLinux}}
#define TTL_FREEBSD {{.Constants.TTLFreeBSD}}
#define TTL_SOLARIS {{.Constants.TTLSolaris}}

// OS Fingerprint Values (Window Size)
#define WINDOW_WINDOWS {{.Constants.WindowWindows}}
#define WINDOW_LINUX {{.Constants.WindowLinux}}
#define WINDOW_FREEBSD {{.Constants.WindowFreeBSD}}

// Egress DLP Configuration
#define MAX_PAYLOAD_SCAN {{.Constants.MaxPayloadScan}}

// Critical asset ports protected by Phantom Protocol (default: DROP all traffic)
// Generated from CriticalPortDefinitions in internal/config/ports.go
{{range .CriticalPorts}}
#define {{.Alias}} {{.Port}}  // {{.Name}} - {{.Description}}
{{end}}

// Fake ports for honeypot deception (The Mirage)
// Generated from FakePortDefinitions in internal/config/ports.go
{{range .FakePorts}}
#define {{.Alias}} {{.Port}}  // {{.Name}} - {{.Description}}
{{end}}
`

const ebpfFunctionTemplate = `// AUTO-GENERATED FUNCTION - DO NOT EDIT MANUALLY
// This function is generated from internal/config/ports.go
// Run 'make generate-config' to regenerate

static __always_inline int is_critical_asset_port(__be16 port) {
    __u16 p = bpf_ntohs(port);
    
{{range .Categories}}
    // {{.Name}}
{{range .Ports}}
    if (p == {{.Alias}}) return 1;
{{end}}
{{end}}
    
    return 0;
}

static __always_inline int is_fake_port(__be16 port) {
    __u16 p = bpf_ntohs(port);
    
{{range .FakePorts}}
    if (p == {{.Alias}}) return 1;
{{end}}
    
    return 0;
}
`

type CategoryGroup struct {
        Name  string
        Ports []config.PortDefinition
}

func main() <span class="cov0" title="0">{
        // Custom usage function
        flag.Usage = func() </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Config Generator - Generate eBPF Configuration from Go Config\n\n")
                fmt.Fprintf(os.Stderr, "Usage: %s [options]\n\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "This tool reads port definitions from internal/config/ports.go and\n")
                fmt.Fprintf(os.Stderr, "generates eBPF C header files (phantom_ports.h) and functions\n")
                fmt.Fprintf(os.Stderr, "(phantom_ports_functions.c) for use in eBPF programs.\n\n")
                fmt.Fprintf(os.Stderr, "Options:\n")
                flag.PrintDefaults()
                fmt.Fprintf(os.Stderr, "\nExamples:\n")
                fmt.Fprintf(os.Stderr, "  # Generate eBPF configuration\n")
                fmt.Fprintf(os.Stderr, "  %s\n\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "  # Or use make\n")
                fmt.Fprintf(os.Stderr, "  make generate-config\n\n")
                fmt.Fprintf(os.Stderr, "Output files:\n")
                fmt.Fprintf(os.Stderr, "  - internal/ebpf/programs/phantom_ports.h\n")
                fmt.Fprintf(os.Stderr, "  - internal/ebpf/programs/phantom_ports_functions.c\n")
        }</span>

        <span class="cov0" title="0">helpFlag := flag.Bool("h", false, "Show help message")
        helpFlag2 := flag.Bool("help", false, "Show help message")
        flag.Parse()

        // Show help if requested
        if *helpFlag || *helpFlag2 </span><span class="cov0" title="0">{
                flag.Usage()
                os.Exit(0)
        }</span>

        // Validate configuration
        <span class="cov0" title="0">if err := config.ValidatePorts(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: Port validation failed: %v\n", err)
                os.Exit(1)
        }</span>

        // Group critical ports by category
        <span class="cov0" title="0">categoryMap := make(map[string][]config.PortDefinition)
        for _, def := range config.CriticalPortDefinitions </span><span class="cov0" title="0">{
                categoryMap[def.Category] = append(categoryMap[def.Category], def)
        }</span>

        // Sort categories and ports within categories
        <span class="cov0" title="0">var categories []CategoryGroup
        for cat, ports := range categoryMap </span><span class="cov0" title="0">{
                sort.Slice(ports, func(i, j int) bool </span><span class="cov0" title="0">{
                        return ports[i].Port &lt; ports[j].Port
                }</span>)
                <span class="cov0" title="0">categories = append(categories, CategoryGroup{
                        Name:  getCategoryName(cat),
                        Ports: ports,
                })</span>
        }
        <span class="cov0" title="0">sort.Slice(categories, func(i, j int) bool </span><span class="cov0" title="0">{
                return categories[i].Name &lt; categories[j].Name
        }</span>)

        // Sort fake ports
        <span class="cov0" title="0">fakePorts := make([]config.PortDefinition, len(config.FakePortDefinitions))
        copy(fakePorts, config.FakePortDefinitions)
        sort.Slice(fakePorts, func(i, j int) bool </span><span class="cov0" title="0">{
                return fakePorts[i].Port &lt; fakePorts[j].Port
        }</span>)

        // Get eBPF constants
        <span class="cov0" title="0">constants := config.GetEBPFConstants()

        // Generate eBPF header defines
        generateEBPFHeader(categories, fakePorts, constants)

        // Generate eBPF function
        generateEBPFFunction(categories, fakePorts)

        fmt.Println("Configuration generation complete!")
        fmt.Printf("Generated %d critical port definitions\n", len(config.CriticalPortDefinitions))
        fmt.Printf("Generated %d fake port definitions\n", len(config.FakePortDefinitions))</span>
}

func generateEBPFHeader(categories []CategoryGroup, fakePorts []config.PortDefinition, constants config.EBFPConstants) <span class="cov0" title="0">{
        tmpl, err := template.New("ebpfHeader").Parse(ebpfHeaderTemplate)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error parsing template: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">outputPath := filepath.Join("internal", "ebpf", "programs", "phantom_ports.h")
        file, err := os.Create(outputPath)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error creating file: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // Collect all critical ports
        var allCriticalPorts []config.PortDefinition
        for _, cat := range categories </span><span class="cov0" title="0">{
                allCriticalPorts = append(allCriticalPorts, cat.Ports...)
        }</span>
        <span class="cov0" title="0">sort.Slice(allCriticalPorts, func(i, j int) bool </span><span class="cov0" title="0">{
                return allCriticalPorts[i].Port &lt; allCriticalPorts[j].Port
        }</span>)

        <span class="cov0" title="0">data := struct {
                Constants     config.EBFPConstants
                CriticalPorts []config.PortDefinition
                FakePorts     []config.PortDefinition
        }{
                Constants:     constants,
                CriticalPorts: allCriticalPorts,
                FakePorts:     fakePorts,
        }

        if err := tmpl.Execute(file, data); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error executing template: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Generated: %s\n", outputPath)</span>
}

func generateEBPFFunction(categories []CategoryGroup, fakePorts []config.PortDefinition) <span class="cov0" title="0">{
        tmpl, err := template.New("ebpfFunction").Parse(ebpfFunctionTemplate)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error parsing template: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">outputPath := filepath.Join("internal", "ebpf", "programs", "phantom_ports_functions.c")
        file, err := os.Create(outputPath)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error creating file: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        data := struct {
                Categories []CategoryGroup
                FakePorts  []config.PortDefinition
        }{
                Categories: categories,
                FakePorts:  fakePorts,
        }

        if err := tmpl.Execute(file, data); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error executing template: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Generated: %s\n", outputPath)</span>
}

func getCategoryName(cat string) string <span class="cov0" title="0">{
        names := map[string]string{
                config.CategoryCore:        "Core Services",
                config.CategoryDatabase:    "Databases",
                config.CategoryAdmin:       "Admin Panels &amp; Management",
                config.CategoryRemote:      "Remote Access",
                config.CategoryContainer:   "Container Services",
                config.CategoryApplication: "Application Frameworks",
                config.CategoryDirectory:   "Directory Services",
                config.CategoryCache:       "Cache Services",
                config.CategoryFile:        "File Services",
                config.CategoryMessaging:   "Messaging Protocols",
        }
        if name, ok := names[cat]; ok </span><span class="cov0" title="0">{
                return name
        }</span>
        <span class="cov0" title="0">return strings.Title(cat)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "bufio"
        "crypto/rand"
        "encoding/base64"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "runtime"
        "strings"

        "phantom-grid/internal/config"
)

var (
        menuColorReset  = "\033[0m"
        menuColorBold   = "\033[1m"
        menuColorCyan   = "\033[36m"
        menuColorGreen  = "\033[32m"
        menuColorYellow = "\033[33m"
        menuColorRed    = "\033[31m"
)

func init() <span class="cov0" title="0">{
        // Disable colors on Windows
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                menuColorReset = ""
                menuColorBold = ""
                menuColorCyan = ""
                menuColorGreen = ""
                menuColorYellow = ""
                menuColorRed = ""
        }</span>
}

func main() <span class="cov0" title="0">{

        clearScreen()
        showBanner()

        for </span><span class="cov0" title="0">{
                showMainMenu()
                choice := getUserInput("Select an option: ")

                switch choice </span>{
                case "1":<span class="cov0" title="0">
                        handleKeyManagement()</span>
                case "2":<span class="cov0" title="0">
                        handleAgentManagement()</span>
                case "3":<span class="cov0" title="0">
                        handleSPATest()</span>
                case "4":<span class="cov0" title="0">
                        handleConfiguration()</span>
                case "5":<span class="cov0" title="0">
                        handleSystemInfo()</span>
                case "6":<span class="cov0" title="0">
                        handleDocumentation()</span>
                case "0", "q", "exit":<span class="cov0" title="0">
                        fmt.Println("\n" + menuColorGreen + "[+] Exiting Phantom Grid. Stay secure!" + menuColorReset)
                        os.Exit(0)</span>
                default:<span class="cov0" title="0">
                        fmt.Println(menuColorRed + "[!] Invalid option. Please try again." + menuColorReset)
                        pause()</span>
                }
        }
}

func clearScreen() <span class="cov0" title="0">{
        var cmd *exec.Cmd
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                cmd = exec.Command("cmd", "/c", "cls")
        }</span> else<span class="cov0" title="0"> {
                cmd = exec.Command("clear")
        }</span>
        <span class="cov0" title="0">cmd.Stdout = os.Stdout
        cmd.Run()</span>
}

func showBanner() <span class="cov0" title="0">{
        banner := `
` + menuColorCyan + menuColorBold + `
╔══════════════════════════════════════════════════════════════╗
║                                                              ║
║          ` + menuColorGreen + `PHANTOM GRID` + menuColorCyan + ` - Active Defense System          ║
║                                                              ║
║              Kernel-level Network Protection                 ║
║                                                              ║
╚══════════════════════════════════════════════════════════════╝
` + menuColorReset
        fmt.Print(banner)
}</span>

func showMainMenu() <span class="cov0" title="0">{
        fmt.Println("\n" + menuColorBold + "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" + menuColorReset)
        fmt.Println(menuColorBold + "                              MAIN MENU" + menuColorReset)
        fmt.Println(menuColorBold + "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" + menuColorReset)
        fmt.Println()
        fmt.Println("  " + menuColorCyan + "[1]" + menuColorReset + " Key Management")
        fmt.Println("     Generate and manage SPA keys")
        fmt.Println()
        fmt.Println("  " + menuColorCyan + "[2]" + menuColorReset + " Agent Management")
        fmt.Println("     Start, stop, and configure the agent")
        fmt.Println()
        fmt.Println("  " + menuColorCyan + "[3]" + menuColorReset + " SPA Testing")
        fmt.Println("     Test Single Packet Authorization")
        fmt.Println()
        fmt.Println("  " + menuColorCyan + "[4]" + menuColorReset + " Configuration")
        fmt.Println("     Configure ports, output modes, and settings")
        fmt.Println()
        fmt.Println("  " + menuColorCyan + "[5]" + menuColorReset + " System Information")
        fmt.Println("     View system status and statistics")
        fmt.Println()
        fmt.Println("  " + menuColorCyan + "[6]" + menuColorReset + " Documentation")
        fmt.Println("     View documentation and guides")
        fmt.Println()
        fmt.Println("  " + menuColorYellow + "[0]" + menuColorReset + " Exit")
        fmt.Println()
}</span>

func handleKeyManagement() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                clearScreen()
                fmt.Println(menuColorBold + "\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" + menuColorReset)
                fmt.Println(menuColorBold + "                         KEY MANAGEMENT" + menuColorReset)
                fmt.Println(menuColorBold + "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" + menuColorReset)
                fmt.Println()
                fmt.Println("  [1] Generate Ed25519 Key Pair")
                fmt.Println("  [2] Generate TOTP Secret")
                fmt.Println("  [3] View Key Status")
                fmt.Println("  [4] Copy Keys to Client")
                fmt.Println("  [0] Back to Main Menu")
                fmt.Println()

                choice := getUserInput("Select an option: ")

                switch choice </span>{
                case "1":<span class="cov0" title="0">
                        generateKeys()</span>
                case "2":<span class="cov0" title="0">
                        generateTOTPSecret()</span>
                case "3":<span class="cov0" title="0">
                        viewKeyStatus()</span>
                case "4":<span class="cov0" title="0">
                        copyKeysToClient()</span>
                case "0":<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0">
                        fmt.Println(menuColorRed + "[!] Invalid option." + menuColorReset)
                        pause()</span>
                }
        }
}

func generateKeys() <span class="cov0" title="0">{
        fmt.Println("\n" + menuColorCyan + "[*] Generating Ed25519 key pair..." + menuColorReset)

        keyDir := getUserInputWithDefault("Key directory", "./keys")

        // Check if keys exist
        publicKeyPath := filepath.Join(keyDir, "spa_public.key")
        if _, err := os.Stat(publicKeyPath); err == nil </span><span class="cov0" title="0">{
                overwrite := getUserInput("Keys already exist. Overwrite? (y/N): ")
                if strings.ToLower(overwrite) != "y" </span><span class="cov0" title="0">{
                        fmt.Println(menuColorYellow + "[*] Cancelled." + menuColorReset)
                        pause()
                        return
                }</span>
        }

        // Run spa-keygen
        <span class="cov0" title="0">cmd := exec.Command("go", "run", "./cmd/spa-keygen", "-dir", keyDir, "-force")
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                fmt.Println(menuColorRed + "[!] Failed to generate keys: " + err.Error() + menuColorReset)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println(menuColorGreen + "[+] Keys generated successfully!" + menuColorReset)
        }</span>

        <span class="cov0" title="0">pause()</span>
}

func generateTOTPSecret() <span class="cov0" title="0">{
        fmt.Println("\n" + menuColorCyan + "[*] Generating TOTP secret..." + menuColorReset)

        keyDir := getUserInputWithDefault("Key directory", "./keys")
        secretPath := filepath.Join(keyDir, "totp_secret.txt")

        // Check if secret exists
        if _, err := os.Stat(secretPath); err == nil </span><span class="cov0" title="0">{
                overwrite := getUserInput("TOTP secret already exists. Overwrite? (y/N): ")
                if strings.ToLower(overwrite) != "y" </span><span class="cov0" title="0">{
                        fmt.Println(menuColorYellow + "[*] Cancelled." + menuColorReset)
                        pause()
                        return
                }</span>
        }

        // Generate secret using script or openssl
        <span class="cov0" title="0">var cmd *exec.Cmd
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                // Use PowerShell script
                scriptPath := "./scripts/generate-totp-secret.ps1"
                if _, err := os.Stat(scriptPath); err == nil </span><span class="cov0" title="0">{
                        cmd = exec.Command("powershell", "-ExecutionPolicy", "Bypass", "-File", scriptPath, secretPath)
                }</span> else<span class="cov0" title="0"> {
                        // Fallback: use Go to generate
                        generateTOTPSecretGo(secretPath)
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                // Use shell script
                scriptPath := "./scripts/generate-totp-secret.sh"
                if _, err := os.Stat(scriptPath); err == nil </span><span class="cov0" title="0">{
                        cmd = exec.Command("bash", scriptPath, secretPath)
                }</span> else<span class="cov0" title="0"> {
                        // Fallback: use openssl
                        cmd = exec.Command("sh", "-c", fmt.Sprintf("openssl rand -base64 32 &gt; %s &amp;&amp; chmod 600 %s", secretPath, secretPath))
                }</span>
        }

        <span class="cov0" title="0">cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                // Fallback to Go implementation
                generateTOTPSecretGo(secretPath)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println(menuColorGreen + "[+] TOTP secret generated successfully!" + menuColorReset)
                fmt.Println(menuColorCyan + "[*] Secret saved to: " + secretPath + menuColorReset)
        }</span>

        <span class="cov0" title="0">pause()</span>
}

func generateTOTPSecretGo(path string) <span class="cov0" title="0">{
        // Generate 32 random bytes
        secret := make([]byte, 32)
        if _, err := rand.Read(secret); err != nil </span><span class="cov0" title="0">{
                fmt.Println(menuColorRed + "[!] Failed to generate random secret: " + err.Error() + menuColorReset)
                return
        }</span>

        // Encode to base64
        <span class="cov0" title="0">encoded := base64.StdEncoding.EncodeToString(secret)

        // Write to file
        if err := os.WriteFile(path, []byte(encoded), 0600); err != nil </span><span class="cov0" title="0">{
                fmt.Println(menuColorRed + "[!] Failed to write TOTP secret: " + err.Error() + menuColorReset)
                return
        }</span>

        <span class="cov0" title="0">fmt.Println(menuColorGreen + "[+] TOTP secret generated successfully!" + menuColorReset)
        fmt.Println(menuColorCyan + "[*] Secret saved to: " + path + menuColorReset)</span>
}

func viewKeyStatus() <span class="cov0" title="0">{
        fmt.Println("\n" + menuColorCyan + "[*] Checking key status..." + menuColorReset)

        keyDir := getUserInputWithDefault("Key directory", "./keys")

        publicKeyPath := filepath.Join(keyDir, "spa_public.key")
        privateKeyPath := filepath.Join(keyDir, "spa_private.key")
        totpSecretPath := filepath.Join(keyDir, "totp_secret.txt")

        fmt.Println()
        fmt.Println(menuColorBold + "Key Status:" + menuColorReset)
        fmt.Println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")

        checkFile("Public Key", publicKeyPath)
        checkFile("Private Key", privateKeyPath)
        checkFile("TOTP Secret", totpSecretPath)

        pause()
}</span>

func checkFile(name, path string) <span class="cov0" title="0">{
        if info, err := os.Stat(path); err == nil </span><span class="cov0" title="0">{
                fmt.Printf("  %s: %s %s(%d bytes)%s\n",
                        name,
                        menuColorGreen+"[OK]"+menuColorReset,
                        menuColorCyan,
                        info.Size(),
                        menuColorReset)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("  %s: %s %s(not found)%s\n",
                        name,
                        menuColorRed+"[MISSING]"+menuColorReset,
                        menuColorYellow,
                        menuColorReset)
        }</span>
}

func copyKeysToClient() <span class="cov0" title="0">{
        fmt.Println("\n" + menuColorCyan + "[*] Copy Keys to Client" + menuColorReset)
        fmt.Println()
        fmt.Println("To copy keys to a client machine, use one of these methods:")
        fmt.Println()
        fmt.Println(menuColorBold + "Method 1: SCP (Linux/macOS)" + menuColorReset)
        fmt.Println("  scp keys/spa_private.key user@client-ip:~/.phantom-grid/")
        fmt.Println("  scp keys/totp_secret.txt user@client-ip:~/.phantom-grid/")
        fmt.Println()
        fmt.Println(menuColorBold + "Method 2: Manual Copy" + menuColorReset)
        fmt.Println("  1. Copy keys/spa_private.key to client")
        fmt.Println("  2. Copy keys/totp_secret.txt to client")
        fmt.Println("  3. Set permissions: chmod 600 ~/.phantom-grid/*")
        fmt.Println()

        keyDir := getUserInputWithDefault("Key directory", "./keys")
        fmt.Println()
        fmt.Println(menuColorCyan + "[*] Keys location: " + keyDir + menuColorReset)

        pause()
}</span>

func handleAgentManagement() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                clearScreen()
                fmt.Println(menuColorBold + "\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" + menuColorReset)
                fmt.Println(menuColorBold + "                        AGENT MANAGEMENT" + menuColorReset)
                fmt.Println(menuColorBold + "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" + menuColorReset)
                fmt.Println()
                fmt.Println("  [1] Start Agent (Interactive)")
                fmt.Println("  [2] Start Agent (Background)")
                fmt.Println("  [3] Stop Agent")
                fmt.Println("  [4] View Agent Status")
                fmt.Println("  [5] Configure Agent")
                fmt.Println("  [0] Back to Main Menu")
                fmt.Println()

                choice := getUserInput("Select an option: ")

                switch choice </span>{
                case "1":<span class="cov0" title="0">
                        startAgentInteractive()</span>
                case "2":<span class="cov0" title="0">
                        startAgentBackground()</span>
                case "3":<span class="cov0" title="0">
                        stopAgent()</span>
                case "4":<span class="cov0" title="0">
                        viewAgentStatus()</span>
                case "5":<span class="cov0" title="0">
                        configureAgent()</span>
                case "0":<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0">
                        fmt.Println(menuColorRed + "[!] Invalid option." + menuColorReset)
                        pause()</span>
                }
        }
}

func isRoot() bool <span class="cov0" title="0">{
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                // On Windows, check if running as administrator
                // Try to open a system device that requires admin privileges
                _, err := os.Open("\\\\.\\PHYSICALDRIVE0")
                return err == nil
        }</span>
        // On Unix-like systems, check if UID is 0
        // Note: os.Geteuid() may not be available on all systems, but it's standard on Linux
        <span class="cov0" title="0">if runtime.GOOS == "linux" || runtime.GOOS == "darwin" || runtime.GOOS == "freebsd" </span><span class="cov0" title="0">{
                return os.Geteuid() == 0
        }</span>
        // For other Unix-like systems, assume not root if we can't check
        <span class="cov0" title="0">return false</span>
}

func startAgentInteractive() <span class="cov0" title="0">{
        fmt.Println("\n" + menuColorCyan + "[*] Starting agent interactively..." + menuColorReset)

        // Check platform
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                fmt.Println(menuColorRed + "[!] ERROR: Phantom Grid agent requires Linux with eBPF/XDP support." + menuColorReset)
                fmt.Println(menuColorYellow + "[*] eBPF/XDP is not available on Windows." + menuColorReset)
                fmt.Println(menuColorCyan + "[*] Please run the agent on a Linux system (kernel 5.4+)." + menuColorReset)
                pause()
                return
        }</span>

        // Check if running as root
        <span class="cov0" title="0">if !isRoot() </span><span class="cov0" title="0">{
                fmt.Println(menuColorYellow + "[!] Warning: Agent requires root privileges for eBPF/XDP operations." + menuColorReset)
                fmt.Println(menuColorCyan + "[*] The command will be run with 'sudo'. You may be prompted for your password." + menuColorReset)
                fmt.Println()
        }</span>

        // Get configuration
        <span class="cov0" title="0">interfaceName := getUserInputWithDefault("Network interface", "")
        spaMode := getUserInputWithDefault("SPA mode (static/dynamic/asymmetric)", "asymmetric")
        outputMode := getUserInputWithDefault("Output mode (dashboard/elk/both)", "dashboard")

        // Build command arguments
        args := []string{"run", "./cmd/agent"}
        if interfaceName != "" </span><span class="cov0" title="0">{
                args = append(args, "-interface", interfaceName)
        }</span>
        <span class="cov0" title="0">args = append(args, "-spa-mode", spaMode)
        args = append(args, "-output", outputMode)

        if spaMode == "static" </span><span class="cov0" title="0">{
                // For static mode, ask for token
                staticToken := getUserInputWithDefault("Static token (press Enter to prompt later)", "")
                if staticToken != "" </span><span class="cov0" title="0">{
                        args = append(args, "-spa-static-token", staticToken)
                }</span>
        } else<span class="cov0" title="0"> {
                // For dynamic modes, ask for key directory
                keyDir := getUserInputWithDefault("Key directory", "./keys")
                args = append(args, "-spa-key-dir", keyDir)
        }</span>

        <span class="cov0" title="0">if outputMode == "elk" || outputMode == "both" </span><span class="cov0" title="0">{
                elkAddr := getUserInputWithDefault("Elasticsearch address", "http://localhost:9200")
                args = append(args, "-elk-address", elkAddr)
        }</span>

        // Build command - use sudo if not root
        <span class="cov0" title="0">var cmd *exec.Cmd
        if !isRoot() </span><span class="cov0" title="0">{
                // Need to use sudo - preserve environment with -E flag
                sudoArgs := append([]string{"-E", "go"}, args...)
                cmd = exec.Command("sudo", sudoArgs...)
                fmt.Println()
                fmt.Println(menuColorYellow + "[*] Running with sudo: sudo go " + strings.Join(args, " ") + menuColorReset)
        }</span> else<span class="cov0" title="0"> {
                // Already root
                cmd = exec.Command("go", args...)
                fmt.Println()
                fmt.Println(menuColorYellow + "[*] Starting agent with: go " + strings.Join(args, " ") + menuColorReset)
        }</span>

        <span class="cov0" title="0">fmt.Println(menuColorYellow + "[*] Press Ctrl+C to stop" + menuColorReset)
        fmt.Println()

        // Set up command I/O
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        cmd.Stdin = os.Stdin

        // Run agent
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                fmt.Println()
                fmt.Println(menuColorRed + "[!] Agent failed to start. Possible reasons:" + menuColorReset)
                if !isRoot() </span><span class="cov0" title="0">{
                        fmt.Println(menuColorYellow + "    1. Permission denied - sudo password may be required or incorrect" + menuColorReset)
                }</span>
                <span class="cov0" title="0">fmt.Println(menuColorYellow + "    2. eBPF not supported - requires Linux kernel 5.4+" + menuColorReset)
                fmt.Println(menuColorYellow + "    3. Interface not found - check interface name" + menuColorReset)
                fmt.Println(menuColorYellow + "    4. Missing dependencies - ensure clang, llvm, libbpf-dev are installed" + menuColorReset)
                fmt.Println()
                if !isRoot() </span><span class="cov0" title="0">{
                        fmt.Println(menuColorCyan + "[*] Try running manually: sudo go run ./cmd/agent -interface " + interfaceName + menuColorReset)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println(menuColorCyan + "[*] Try running manually: go run ./cmd/agent -interface " + interfaceName + menuColorReset)
                }</span>
                <span class="cov0" title="0">fmt.Println()
                fmt.Println(menuColorRed + "[!] Error details: " + err.Error() + menuColorReset)</span>
        }

        <span class="cov0" title="0">pause()</span>
}

func startAgentBackground() <span class="cov0" title="0">{
        fmt.Println(menuColorYellow + "[!] Background mode not yet implemented." + menuColorReset)
        fmt.Println(menuColorCyan + "[*] Use systemd or screen/tmux for background execution." + menuColorReset)
        pause()
}</span>

func stopAgent() <span class="cov0" title="0">{
        fmt.Println("\n" + menuColorCyan + "[*] Stopping agent..." + menuColorReset)

        var cmd *exec.Cmd
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                cmd = exec.Command("taskkill", "/F", "/IM", "phantom-grid.exe")
        }</span> else<span class="cov0" title="0"> {
                cmd = exec.Command("pkill", "-f", "phantom-grid")
        }</span>

        <span class="cov0" title="0">cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                fmt.Println(menuColorYellow + "[*] No running agent found or failed to stop." + menuColorReset)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println(menuColorGreen + "[+] Agent stopped successfully." + menuColorReset)
        }</span>

        <span class="cov0" title="0">pause()</span>
}

func viewAgentStatus() <span class="cov0" title="0">{
        fmt.Println("\n" + menuColorCyan + "[*] Checking agent status..." + menuColorReset)

        var cmd *exec.Cmd
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                cmd = exec.Command("tasklist", "/FI", "IMAGENAME eq phantom-grid.exe")
        }</span> else<span class="cov0" title="0"> {
                cmd = exec.Command("pgrep", "-f", "phantom-grid")
        }</span>

        <span class="cov0" title="0">output, err := cmd.Output()
        if err != nil || len(output) == 0 </span><span class="cov0" title="0">{
                fmt.Println(menuColorYellow + "[*] Agent is not running." + menuColorReset)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println(menuColorGreen + "[+] Agent is running:" + menuColorReset)
                fmt.Println(string(output))
        }</span>

        <span class="cov0" title="0">pause()</span>
}

func configureAgent() <span class="cov0" title="0">{
        fmt.Println(menuColorYellow + "[!] Agent configuration editor not yet implemented." + menuColorReset)
        fmt.Println(menuColorCyan + "[*] Edit internal/config/ports.go to configure ports." + menuColorReset)
        fmt.Println(menuColorCyan + "[*] Use command-line flags to configure runtime options." + menuColorReset)
        pause()
}</span>

func handleSPATest() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                clearScreen()
                fmt.Println(menuColorBold + "\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" + menuColorReset)
                fmt.Println(menuColorBold + "                            SPA TESTING" + menuColorReset)
                fmt.Println(menuColorBold + "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" + menuColorReset)
                fmt.Println()
                fmt.Println("  [1] Quick Send (Auto-detect keys)")
                fmt.Println("  [2] Custom Configuration")
                fmt.Println("  [3] Static SPA (Legacy)")
                fmt.Println("  [0] Back to Main Menu")
                fmt.Println()

                choice := getUserInput("Select an option: ")

                switch choice </span>{
                case "1":<span class="cov0" title="0">
                        quickSendSPA()</span>
                case "2":<span class="cov0" title="0">
                        customSPA()</span>
                case "3":<span class="cov0" title="0">
                        staticSPA()</span>
                case "0":<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0">
                        fmt.Println(menuColorRed + "[!] Invalid option." + menuColorReset)
                        pause()</span>
                }
        }
}

func quickSendSPA() <span class="cov0" title="0">{
        clearScreen()
        fmt.Println(menuColorBold + "\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" + menuColorReset)
        fmt.Println(menuColorBold + "                         QUICK SPA SEND" + menuColorReset)
        fmt.Println(menuColorBold + "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" + menuColorReset)
        fmt.Println()

        serverIP := getUserInput("Server IP address: ")
        if serverIP == "" </span><span class="cov0" title="0">{
                fmt.Println(menuColorRed + "[!] Server IP is required." + menuColorReset)
                pause()
                return
        }</span>

        <span class="cov0" title="0">fmt.Println()
        fmt.Println(menuColorCyan + "[*] Auto-detecting keys..." + menuColorReset)

        // Try to find keys automatically
        keyPaths := []string{
                "./keys/spa_private.key",
                filepath.Join(os.Getenv("HOME"), ".phantom-grid", "spa_private.key"),
                filepath.Join(os.Getenv("USERPROFILE"), ".phantom-grid", "spa_private.key"), // Windows
        }

        var keyPath string
        for _, path := range keyPaths </span><span class="cov0" title="0">{
                if _, err := os.Stat(path); err == nil </span><span class="cov0" title="0">{
                        keyPath = path
                        fmt.Println(menuColorGreen + "[+] Found private key: " + path + menuColorReset)
                        break</span>
                }
        }

        <span class="cov0" title="0">if keyPath == "" </span><span class="cov0" title="0">{
                fmt.Println(menuColorRed + "[!] Private key not found in default locations:" + menuColorReset)
                for _, path := range keyPaths </span><span class="cov0" title="0">{
                        fmt.Println(menuColorYellow + "    - " + path + menuColorReset)
                }</span>
                <span class="cov0" title="0">fmt.Println()
                fmt.Println(menuColorCyan + "[*] Please copy keys from server or use Custom Configuration option." + menuColorReset)
                pause()
                return</span>
        }

        // Try to find TOTP secret
        <span class="cov0" title="0">totpPaths := []string{
                "./keys/totp_secret.txt",
                filepath.Join(os.Getenv("HOME"), ".phantom-grid", "totp_secret.txt"),
                filepath.Join(os.Getenv("USERPROFILE"), ".phantom-grid", "totp_secret.txt"), // Windows
        }

        var totpPath string
        for _, path := range totpPaths </span><span class="cov0" title="0">{
                if _, err := os.Stat(path); err == nil </span><span class="cov0" title="0">{
                        totpPath = path
                        fmt.Println(menuColorGreen + "[+] Found TOTP secret: " + path + menuColorReset)
                        break</span>
                }
        }

        <span class="cov0" title="0">if totpPath == "" </span><span class="cov0" title="0">{
                fmt.Println(menuColorYellow + "[!] TOTP secret not found. Sending without TOTP (may fail if server requires it)." + menuColorReset)
        }</span>

        <span class="cov0" title="0">fmt.Println()
        fmt.Println(menuColorCyan + "[*] Sending SPA packet to " + serverIP + "..." + menuColorReset)
        fmt.Println()

        // Build command
        args := []string{"run", "./cmd/spa-client", "-server", serverIP, "-mode", "asymmetric", "-key", keyPath}
        if totpPath != "" </span><span class="cov0" title="0">{
                args = append(args, "-totp", totpPath)
        }</span>

        <span class="cov0" title="0">cmd := exec.Command("go", args...)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                fmt.Println()
                fmt.Println(menuColorRed + "[!] SPA send failed: " + err.Error() + menuColorReset)
                fmt.Println(menuColorYellow + "[*] Check:" + menuColorReset)
                fmt.Println(menuColorYellow + "    1. Server is running and accessible" + menuColorReset)
                fmt.Println(menuColorYellow + "    2. Keys match between client and server" + menuColorReset)
                fmt.Println(menuColorYellow + "    3. TOTP secret matches (if used)" + menuColorReset)
                fmt.Println(menuColorYellow + "    4. Firewall allows UDP port " + fmt.Sprintf("%d", config.SPAMagicPort) + menuColorReset)
        }</span>

        <span class="cov0" title="0">pause()</span>
}

func customSPA() <span class="cov0" title="0">{
        clearScreen()
        fmt.Println(menuColorBold + "\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" + menuColorReset)
        fmt.Println(menuColorBold + "                      CUSTOM SPA CONFIGURATION" + menuColorReset)
        fmt.Println(menuColorBold + "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" + menuColorReset)
        fmt.Println()

        serverIP := getUserInput("Server IP address: ")
        if serverIP == "" </span><span class="cov0" title="0">{
                fmt.Println(menuColorRed + "[!] Server IP is required." + menuColorReset)
                pause()
                return
        }</span>

        <span class="cov0" title="0">mode := getUserInputWithDefault("SPA mode (static/dynamic/asymmetric)", "asymmetric")

        args := []string{"run", "./cmd/spa-client", "-server", serverIP, "-mode", mode}

        if mode != "static" </span><span class="cov0" title="0">{
                keyPath := getUserInputWithDefault("Private key path", "./keys/spa_private.key")
                args = append(args, "-key", keyPath)

                totpPath := getUserInputWithDefault("TOTP secret path (press Enter to skip)", "")
                if totpPath != "" </span><span class="cov0" title="0">{
                        args = append(args, "-totp", totpPath)
                }</span>
        }

        <span class="cov0" title="0">fmt.Println()
        fmt.Println(menuColorCyan + "[*] Sending SPA packet..." + menuColorReset)
        fmt.Println()

        cmd := exec.Command("go", args...)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                fmt.Println(menuColorRed + "[!] SPA send failed: " + err.Error() + menuColorReset)
        }</span>

        <span class="cov0" title="0">pause()</span>
}

func staticSPA() <span class="cov0" title="0">{
        clearScreen()
        fmt.Println(menuColorBold + "\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" + menuColorReset)
        fmt.Println(menuColorBold + "                         STATIC SPA (LEGACY)" + menuColorReset)
        fmt.Println(menuColorBold + "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" + menuColorReset)
        fmt.Println()
        fmt.Println(menuColorYellow + "[!] Warning: Static SPA is less secure. Use Dynamic Asymmetric SPA for production." + menuColorReset)
        fmt.Println()

        serverIP := getUserInput("Server IP address: ")
        if serverIP == "" </span><span class="cov0" title="0">{
                fmt.Println(menuColorRed + "[!] Server IP is required." + menuColorReset)
                pause()
                return
        }</span>

        <span class="cov0" title="0">token := getUserInputWithDefault("Static token (press Enter for default)", "")

        fmt.Println()
        fmt.Println(menuColorCyan + "[*] Sending static SPA packet..." + menuColorReset)
        fmt.Println()

        args := []string{"run", "./cmd/spa-client", "-server", serverIP, "-mode", "static"}
        if token != "" </span><span class="cov0" title="0">{
                args = append(args, "-static-token", token)
        }</span>

        <span class="cov0" title="0">cmd := exec.Command("go", args...)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                fmt.Println(menuColorRed + "[!] SPA send failed: " + err.Error() + menuColorReset)
        }</span>

        <span class="cov0" title="0">pause()</span>
}

func handleConfiguration() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                clearScreen()
                fmt.Println(menuColorBold + "\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" + menuColorReset)
                fmt.Println(menuColorBold + "                          CONFIGURATION" + menuColorReset)
                fmt.Println(menuColorBold + "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" + menuColorReset)
                fmt.Println()
                fmt.Println("  [1] View Protected Ports")
                fmt.Println("  [2] View Fake Ports (Honeypot)")
                fmt.Println("  [3] Regenerate eBPF Configuration")
                fmt.Println("  [0] Back to Main Menu")
                fmt.Println()

                choice := getUserInput("Select an option: ")

                switch choice </span>{
                case "1":<span class="cov0" title="0">
                        viewProtectedPorts()</span>
                case "2":<span class="cov0" title="0">
                        viewFakePorts()</span>
                case "3":<span class="cov0" title="0">
                        regenerateEBPFConfig()</span>
                case "0":<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0">
                        fmt.Println(menuColorRed + "[!] Invalid option." + menuColorReset)
                        pause()</span>
                }
        }
}

func viewProtectedPorts() <span class="cov0" title="0">{
        fmt.Println("\n" + menuColorCyan + "[*] Protected Ports (Critical Assets):" + menuColorReset)
        fmt.Println()

        ports := config.GetCriticalPorts()
        if len(ports) == 0 </span><span class="cov0" title="0">{
                fmt.Println(menuColorYellow + "[*] No protected ports configured." + menuColorReset)
        }</span> else<span class="cov0" title="0"> {
                for _, port := range ports </span><span class="cov0" title="0">{
                        fmt.Printf("  Port %d: %s\n", port, getPortName(port))
                }</span>
        }

        <span class="cov0" title="0">pause()</span>
}

func viewFakePorts() <span class="cov0" title="0">{
        fmt.Println("\n" + menuColorCyan + "[*] Fake Ports (Honeypot - The Mirage):" + menuColorReset)
        fmt.Println()

        ports := config.GetFakePorts()
        if len(ports) == 0 </span><span class="cov0" title="0">{
                fmt.Println(menuColorYellow + "[*] No fake ports configured." + menuColorReset)
        }</span> else<span class="cov0" title="0"> {
                for _, port := range ports </span><span class="cov0" title="0">{
                        fmt.Printf("  Port %d: %s\n", port, getPortName(port))
                }</span>
        }

        <span class="cov0" title="0">pause()</span>
}

func getPortName(port int) string <span class="cov0" title="0">{
        // Try to find in critical ports
        for _, def := range config.CriticalPortDefinitions </span><span class="cov0" title="0">{
                if def.Port == port </span><span class="cov0" title="0">{
                        return def.Name
                }</span>
        }
        // Try to find in fake ports
        <span class="cov0" title="0">for _, def := range config.FakePortDefinitions </span><span class="cov0" title="0">{
                if def.Port == port </span><span class="cov0" title="0">{
                        return def.Name
                }</span>
        }
        <span class="cov0" title="0">return "Unknown"</span>
}

func regenerateEBPFConfig() <span class="cov0" title="0">{
        fmt.Println("\n" + menuColorCyan + "[*] Regenerating eBPF configuration..." + menuColorReset)

        cmd := exec.Command("go", "run", "./cmd/config-gen")
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                fmt.Println(menuColorRed + "[!] Failed to regenerate configuration: " + err.Error() + menuColorReset)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println(menuColorGreen + "[+] Configuration regenerated successfully!" + menuColorReset)
                fmt.Println(menuColorCyan + "[*] Run 'make generate' to rebuild eBPF programs." + menuColorReset)
        }</span>

        <span class="cov0" title="0">pause()</span>
}

func handleSystemInfo() <span class="cov0" title="0">{
        clearScreen()
        fmt.Println(menuColorBold + "\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" + menuColorReset)
        fmt.Println(menuColorBold + "                        SYSTEM INFORMATION" + menuColorReset)
        fmt.Println(menuColorBold + "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" + menuColorReset)
        fmt.Println()

        fmt.Println(menuColorCyan + "System:" + menuColorReset)
        fmt.Printf("  OS: %s\n", runtime.GOOS)
        fmt.Printf("  Architecture: %s\n", runtime.GOARCH)
        fmt.Println()

        fmt.Println(menuColorCyan + "Configuration:" + menuColorReset)
        fmt.Printf("  SPA Magic Port: %d\n", config.SPAMagicPort)
        fmt.Printf("  SSH Port: %d\n", config.SSHPort)
        fmt.Printf("  Honeypot Port: %d\n", config.HoneypotPort)
        fmt.Printf("  Protected Ports: %d\n", len(config.GetCriticalPorts()))
        fmt.Printf("  Fake Ports: %d\n", len(config.GetFakePorts()))
        fmt.Println()

        fmt.Println(menuColorCyan + "Network Interfaces:" + menuColorReset)
        listNetworkInterfaces()

        pause()
}</span>

func listNetworkInterfaces() <span class="cov0" title="0">{
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                cmd := exec.Command("ipconfig")
                output, _ := cmd.Output()
                fmt.Println(string(output))
        }</span> else<span class="cov0" title="0"> {
                cmd := exec.Command("ip", "link", "show")
                output, _ := cmd.Output()
                fmt.Println(string(output))
        }</span>
}

func handleDocumentation() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                clearScreen()
                fmt.Println(menuColorBold + "\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" + menuColorReset)
                fmt.Println(menuColorBold + "                           DOCUMENTATION" + menuColorReset)
                fmt.Println(menuColorBold + "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" + menuColorReset)
                fmt.Println()
                fmt.Println("  [1] Getting Started Guide")
                fmt.Println("  [2] SPA Mechanism Explained")
                fmt.Println("  [3] Key Management Guide")
                fmt.Println("  [4] Troubleshooting Guide")
                fmt.Println("  [5] Configuration Guide")
                fmt.Println("  [0] Back to Main Menu")
                fmt.Println()

                choice := getUserInput("Select an option: ")

                docs := map[string]string{
                        "1": "docs/GETTING_STARTED.md",
                        "2": "docs/SPA_MECHANISM_EXPLAINED.md",
                        "3": "docs/SPA_KEYS_MANAGEMENT.md",
                        "4": "docs/SPA_TROUBLESHOOTING.md",
                        "5": "docs/CONFIGURING_PORTS.md",
                }

                if doc, ok := docs[choice]; ok </span><span class="cov0" title="0">{
                        viewDocumentation(doc)
                }</span> else<span class="cov0" title="0"> if choice == "0" </span><span class="cov0" title="0">{
                        return
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println(menuColorRed + "[!] Invalid option." + menuColorReset)
                        pause()
                }</span>
        }
}

func viewDocumentation(file string) <span class="cov0" title="0">{
        if _, err := os.Stat(file); err != nil </span><span class="cov0" title="0">{
                fmt.Println(menuColorRed + "[!] Documentation file not found: " + file + menuColorReset)
                pause()
                return
        }</span>

        // Try to open with default viewer
        <span class="cov0" title="0">var cmd *exec.Cmd
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                cmd = exec.Command("notepad", file)
        }</span> else<span class="cov0" title="0"> {
                // Try different viewers
                viewers := []string{"less", "cat", "more"}
                for _, viewer := range viewers </span><span class="cov0" title="0">{
                        if _, err := exec.LookPath(viewer); err == nil </span><span class="cov0" title="0">{
                                cmd = exec.Command(viewer, file)
                                break</span>
                        }
                }
                <span class="cov0" title="0">if cmd == nil </span><span class="cov0" title="0">{
                        cmd = exec.Command("cat", file)
                }</span>
        }

        <span class="cov0" title="0">cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        cmd.Stdin = os.Stdin
        cmd.Run()

        pause()</span>
}

func getUserInput(prompt string) string <span class="cov0" title="0">{
        fmt.Print(menuColorCyan + prompt + menuColorReset)
        reader := bufio.NewReader(os.Stdin)
        input, _ := reader.ReadString('\n')
        return strings.TrimSpace(input)
}</span>

func getUserInputWithDefault(prompt, defaultValue string) string <span class="cov0" title="0">{
        if defaultValue != "" </span><span class="cov0" title="0">{
                fmt.Print(menuColorCyan + prompt + " [" + defaultValue + "]: " + menuColorReset)
        }</span> else<span class="cov0" title="0"> {
                fmt.Print(menuColorCyan + prompt + ": " + menuColorReset)
        }</span>
        <span class="cov0" title="0">reader := bufio.NewReader(os.Stdin)
        input, _ := reader.ReadString('\n')
        input = strings.TrimSpace(input)
        if input == "" </span><span class="cov0" title="0">{
                return defaultValue
        }</span>
        <span class="cov0" title="0">return input</span>
}

func pause() <span class="cov0" title="0">{
        fmt.Println()
        fmt.Print(menuColorYellow + "Press Enter to continue..." + menuColorReset)
        bufio.NewReader(os.Stdin).ReadBytes('\n')
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "flag"
        "fmt"
        "log"
        "os"
        "path/filepath"

        "phantom-grid/internal/config"
        "phantom-grid/pkg/spa"
)

func main() <span class="cov0" title="0">{
        // Custom usage function
        flag.Usage = func() </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "SPA Client - Single Packet Authorization Client\n\n")
                fmt.Fprintf(os.Stderr, "Usage: %s [options]\n\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "Options:\n")
                flag.PrintDefaults()
                fmt.Fprintf(os.Stderr, "\nExamples:\n")
                fmt.Fprintf(os.Stderr, "  # Static SPA (legacy)\n")
                fmt.Fprintf(os.Stderr, "  %s -server 192.168.1.100\n\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "  # Dynamic Asymmetric SPA (auto-detects keys)\n")
                fmt.Fprintf(os.Stderr, "  %s -server 192.168.1.100 -mode asymmetric\n\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "  # With custom key paths\n")
                fmt.Fprintf(os.Stderr, "  %s -server 192.168.1.100 -mode asymmetric -key ~/.phantom-grid/spa_private.key -totp ~/.phantom-grid/totp_secret.txt\n\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "Note: Keys are auto-detected from default locations if not specified.\n")
                fmt.Fprintf(os.Stderr, "See docs/GETTING_STARTED.md for detailed instructions.\n")
        }</span>

        // Parse command line arguments
        <span class="cov0" title="0">serverIP := flag.String("server", "", "Server IP address (required)")
        mode := flag.String("mode", "static", "SPA mode: 'static', 'dynamic', or 'asymmetric'")
        keyPath := flag.String("key", "", "Path to private key file (auto-detected if not specified). Searches: ./keys/spa_private.key, ~/.phantom-grid/spa_private.key")
        totpSecretPath := flag.String("totp", "", "Path to TOTP secret file (auto-detected if not specified). Searches: ./keys/totp_secret.txt, ~/.phantom-grid/totp_secret.txt")
        staticTokenFlag := flag.String("static-token", "", "Static SPA token (for static mode only). If not provided, uses default")
        helpFlag := flag.Bool("h", false, "Show help message")
        helpFlag2 := flag.Bool("help", false, "Show help message")
        
        flag.Parse()

        // Show help if requested
        if *helpFlag || *helpFlag2 </span><span class="cov0" title="0">{
                flag.Usage()
                os.Exit(0)
        }</span>

        // Validate server IP
        <span class="cov0" title="0">if *serverIP == "" </span><span class="cov0" title="0">{
                flag.Usage()
                os.Exit(1)
        }</span>

        // Handle static mode (legacy)
        <span class="cov0" title="0">if *mode == "static" </span><span class="cov0" title="0">{
                var token string
                if *staticTokenFlag != "" </span><span class="cov0" title="0">{
                        token = *staticTokenFlag
                        fmt.Printf("[*] Using custom static token (length: %d)\n", len(token))
                }</span> else<span class="cov0" title="0"> {
                        // Prompt for token
                        fmt.Print("[*] Enter static token (press Enter for default): ")
                        var input string
                        fmt.Scanln(&amp;input)
                        if input != "" </span><span class="cov0" title="0">{
                                token = input
                        }</span> else<span class="cov0" title="0"> {
                                token = config.SPASecretToken
                        }</span>
                }

                <span class="cov0" title="0">client := spa.NewClientWithToken(*serverIP, token)
                fmt.Printf("[*] Sending Static SPA Magic Packet to %s:%d...\n", *serverIP, config.SPAMagicPort)
                if err := client.SendMagicPacket(); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("[!] Error: %v\n", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">fmt.Printf("[*] Sent %d bytes\n", len(token))
                fmt.Println("[+] Magic Packet sent successfully!")
                fmt.Printf("[+] Your IP has been whitelisted for %d seconds\n", config.SPAWhitelistDuration)
                fmt.Println("[+] You can now connect to protected services:")
                fmt.Printf("    ssh user@%s\n", *serverIP)
                fmt.Printf("    ftp %s\n", *serverIP)
                fmt.Println("\n[*] Note: Whitelist expires in 30 seconds")
                return</span>
        }

        // Handle dynamic modes
        <span class="cov0" title="0">spaConfig := config.DefaultDynamicSPAConfig()

        // Set mode
        switch *mode </span>{
        case "dynamic":<span class="cov0" title="0">
                spaConfig.Mode = config.SPAModeDynamic</span>
        case "asymmetric":<span class="cov0" title="0">
                spaConfig.Mode = config.SPAModeAsymmetric</span>
        default:<span class="cov0" title="0">
                log.Fatalf("Invalid mode: %s. Use 'static', 'dynamic', or 'asymmetric'", *mode)</span>
        }

        // Load private key for asymmetric mode
        <span class="cov0" title="0">if spaConfig.Mode == config.SPAModeAsymmetric </span><span class="cov0" title="0">{
                if *keyPath == "" </span><span class="cov0" title="0">{
                        // Try default locations automatically
                        defaultPaths := []string{
                                "./keys/spa_private.key",
                                filepath.Join(os.Getenv("HOME"), ".phantom-grid", "spa_private.key"),
                                filepath.Join(os.Getenv("USERPROFILE"), ".phantom-grid", "spa_private.key"), // Windows
                        }
                        for _, path := range defaultPaths </span><span class="cov0" title="0">{
                                if _, err := os.Stat(path); err == nil </span><span class="cov0" title="0">{
                                        *keyPath = path
                                        fmt.Printf("[*] Auto-detected private key: %s\n", path)
                                        break</span>
                                }
                        }
                }

                <span class="cov0" title="0">if *keyPath == "" </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error: Private key required for asymmetric mode.\n")
                        fmt.Fprintf(os.Stderr, "Searched in:\n")
                        fmt.Fprintf(os.Stderr, "  - ./keys/spa_private.key\n")
                        fmt.Fprintf(os.Stderr, "  - ~/.phantom-grid/spa_private.key\n")
                        fmt.Fprintf(os.Stderr, "  - $USERPROFILE/.phantom-grid/spa_private.key (Windows)\n")
                        fmt.Fprintf(os.Stderr, "\nUse -key flag to specify key path, or copy key to one of the above locations.\n")
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">fmt.Printf("[*] Loading private key from %s...\n", *keyPath)
                _, privateKey, err := config.LoadKeysFromFile("", *keyPath)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to load private key: %v\nMake sure the key file exists and has correct permissions (chmod 600)", err)
                }</span>
                <span class="cov0" title="0">spaConfig.PrivateKey = privateKey
                fmt.Println("[+] Private key loaded")</span>
        }

        // Load TOTP secret - try auto-detect if not provided
        <span class="cov0" title="0">if spaConfig.Mode == config.SPAModeAsymmetric || spaConfig.Mode == config.SPAModeDynamic </span><span class="cov0" title="0">{
                if *totpSecretPath == "" </span><span class="cov0" title="0">{
                        // Try default locations automatically
                        defaultTotpPaths := []string{
                                "./keys/totp_secret.txt",
                                filepath.Join(os.Getenv("HOME"), ".phantom-grid", "totp_secret.txt"),
                                filepath.Join(os.Getenv("USERPROFILE"), ".phantom-grid", "totp_secret.txt"), // Windows
                        }
                        for _, path := range defaultTotpPaths </span><span class="cov0" title="0">{
                                if _, err := os.Stat(path); err == nil </span><span class="cov0" title="0">{
                                        *totpSecretPath = path
                                        fmt.Printf("[*] Auto-detected TOTP secret: %s\n", path)
                                        break</span>
                                }
                        }
                }

                <span class="cov0" title="0">if *totpSecretPath != "" </span><span class="cov0" title="0">{
                        fmt.Printf("[*] Loading TOTP secret from %s...\n", *totpSecretPath)
                        totpSecret, err := os.ReadFile(*totpSecretPath)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatalf("Failed to load TOTP secret: %v\nMake sure the secret file exists", err)
                        }</span>
                        // Remove newline if present
                        <span class="cov0" title="0">if len(totpSecret) &gt; 0 &amp;&amp; totpSecret[len(totpSecret)-1] == '\n' </span><span class="cov0" title="0">{
                                totpSecret = totpSecret[:len(totpSecret)-1]
                        }</span>
                        <span class="cov0" title="0">spaConfig.TOTPSecret = totpSecret
                        fmt.Println("[+] TOTP secret loaded")</span>
                } else<span class="cov0" title="0"> {
                        fmt.Println("[!] Warning: TOTP secret not found. Authentication may fail if server requires it.")
                }</span>
        }

        // Create dynamic client
        <span class="cov0" title="0">fmt.Printf("[*] Creating %s SPA client for server %s...\n", *mode, *serverIP)
        client, err := spa.NewDynamicClient(*serverIP, spaConfig)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create client: %v", err)
        }</span>

        // Send magic packet
        <span class="cov0" title="0">fmt.Printf("[*] Sending %s SPA packet to %s:%d...\n", *mode, *serverIP, config.SPAMagicPort)
        if err := client.SendMagicPacket(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to send packet: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("[+] SPA packet sent successfully!")
        fmt.Printf("[+] Your IP has been whitelisted for %d seconds\n", config.SPAWhitelistDuration)
        fmt.Println("[+] You can now connect to protected services:")
        fmt.Printf("    ssh user@%s\n", *serverIP)
        fmt.Printf("    ftp %s\n", *serverIP)
        fmt.Println("\n[*] Note: Whitelist expires in 30 seconds")</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "flag"
        "fmt"
        "os"
        "path/filepath"

        "phantom-grid/internal/config"
)

func main() <span class="cov0" title="0">{
        // Custom usage function
        flag.Usage = func() </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "SPA Key Generator - Generate Ed25519 Key Pair for Dynamic SPA\n\n")
                fmt.Fprintf(os.Stderr, "Usage: %s [options]\n\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "Options:\n")
                flag.PrintDefaults()
                fmt.Fprintf(os.Stderr, "\nExamples:\n")
                fmt.Fprintf(os.Stderr, "  # Generate keys in default directory (./keys)\n")
                fmt.Fprintf(os.Stderr, "  %s\n\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "  # Generate keys in custom directory\n")
                fmt.Fprintf(os.Stderr, "  %s -dir /etc/phantom-grid/keys\n\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "  # Overwrite existing keys\n")
                fmt.Fprintf(os.Stderr, "  %s -force\n\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "Output files:\n")
                fmt.Fprintf(os.Stderr, "  - spa_public.key  (32 bytes) - Keep on server\n")
                fmt.Fprintf(os.Stderr, "  - spa_private.key (64 bytes) - Distribute to clients securely\n")
        }</span>

        <span class="cov0" title="0">keyDir := flag.String("dir", "./keys", "Directory to save keys")
        force := flag.Bool("force", false, "Overwrite existing keys")
        helpFlag := flag.Bool("h", false, "Show help message")
        helpFlag2 := flag.Bool("help", false, "Show help message")
        
        flag.Parse()

        // Show help if requested
        if *helpFlag || *helpFlag2 </span><span class="cov0" title="0">{
                flag.Usage()
                os.Exit(0)
        }</span>

        // Check if keys already exist
        <span class="cov0" title="0">publicKeyPath := filepath.Join(*keyDir, "spa_public.key")
        privateKeyPath := filepath.Join(*keyDir, "spa_private.key")

        if !*force </span><span class="cov0" title="0">{
                if _, err := os.Stat(publicKeyPath); err == nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error: Keys already exist at %s\n", *keyDir)
                        fmt.Fprintf(os.Stderr, "Use -force to overwrite\n")
                        os.Exit(1)
                }</span>
        }

        // Generate Ed25519 key pair
        <span class="cov0" title="0">fmt.Println("Generating Ed25519 key pair...")
        publicKey, privateKey, err := config.GenerateEd25519Keys()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error generating keys: %v\n", err)
                os.Exit(1)
        }</span>

        // Save keys
        <span class="cov0" title="0">if err := config.SaveKeysToFile(publicKey, privateKey, *keyDir); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error saving keys: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Keys generated successfully!\n")
        fmt.Printf("Public key:  %s\n", publicKeyPath)
        fmt.Printf("Private key: %s\n", privateKeyPath)
        fmt.Printf("\n")
        fmt.Printf("IMPORTANT: Keep the private key secure! It should only be on client machines.\n")
        fmt.Printf("The public key will be loaded into the server's eBPF maps.\n")</span>
}

</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "flag"
        "fmt"
        "log"
        "os"

        "phantom-grid/internal/config"
        "phantom-grid/pkg/spa"
)

func main() <span class="cov0" title="0">{
        // Parse command line arguments
        serverIP := flag.String("server", "", "Server IP address (required)")
        keyPath := flag.String("key", "./keys/spa_private.key", "Path to private key file")
        totpSecretPath := flag.String("totp", "./keys/totp_secret.txt", "Path to TOTP secret file")
        flag.Parse()

        if *serverIP == "" </span><span class="cov0" title="0">{
                flag.Usage()
                log.Fatal("Error: -server flag is required")
        }</span>

        // Load configuration
        <span class="cov0" title="0">spaConfig := config.DefaultDynamicSPAConfig()
        spaConfig.Mode = config.SPAModeAsymmetric

        // Load private key
        fmt.Printf("Loading private key from %s...\n", *keyPath)
        _, privateKey, err := config.LoadKeysFromFile("", *keyPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load private key: %v\nMake sure the key file exists and has correct permissions (chmod 600)", err)
        }</span>
        <span class="cov0" title="0">spaConfig.PrivateKey = privateKey
        fmt.Println("✓ Private key loaded")

        // Load TOTP secret
        fmt.Printf("Loading TOTP secret from %s...\n", *totpSecretPath)
        totpSecret, err := os.ReadFile(*totpSecretPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load TOTP secret: %v\nMake sure the secret file exists", err)
        }</span>
        // Remove newline if present
        <span class="cov0" title="0">if len(totpSecret) &gt; 0 &amp;&amp; totpSecret[len(totpSecret)-1] == '\n' </span><span class="cov0" title="0">{
                totpSecret = totpSecret[:len(totpSecret)-1]
        }</span>
        <span class="cov0" title="0">spaConfig.TOTPSecret = totpSecret
        fmt.Println("✓ TOTP secret loaded")

        // Create client
        fmt.Printf("Creating SPA client for server %s...\n", *serverIP)
        client, err := spa.NewDynamicClient(*serverIP, spaConfig)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create client: %v", err)
        }</span>
        <span class="cov0" title="0">fmt.Println("✓ Client created")

        // Send magic packet
        fmt.Printf("Sending SPA packet to %s:1337...\n", *serverIP)
        if err := client.SendMagicPacket(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to send packet: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("✓ SPA packet sent successfully!")
        fmt.Println("")
        fmt.Println("Your IP should now be whitelisted for 30 seconds.")
        fmt.Println("You can now connect to protected services (SSH, etc.)")</span>
}

</pre>
		
		<pre class="file" id="file6" style="display: none">package agent

import (
        "fmt"
        "log"
        "net"
        "os"

        "github.com/vishvananda/netlink"
        "golang.org/x/sys/unix"

        "phantom-grid/internal/config"
        "phantom-grid/internal/ebpf"
        "phantom-grid/internal/honeypot"
        "phantom-grid/internal/logger"
        "phantom-grid/internal/network"
        "phantom-grid/internal/spa"
)

// Agent represents the main Phantom Grid agent
type Agent struct {
        ebpfLoader  *ebpf.Loader
        iface       *net.Interface
        ifaceName   string
        honeypot    *honeypot.Honeypot
        spaManager  *spa.Manager
        logChan     chan&lt;- string
        logManager  *logger.Manager
        spaConfig   *config.DynamicSPAConfig
        spaHandler  *spa.Handler
        staticToken string // Static token for legacy SPA mode
}

// New creates a new Agent instance
func New(interfaceName string, outputMode config.OutputMode, elkConfig config.ELKConfiguration, dashboardChan chan&lt;- string, spaConfig *config.DynamicSPAConfig, staticToken string) (*Agent, error) <span class="cov0" title="0">{
        // Detect network interface
        iface, ifaceName, err := network.DetectInterface(interfaceName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to detect interface: %w", err)
        }</span>

        // Initialize eBPF loader
        <span class="cov0" title="0">ebpfLoader, err := ebpf.NewLoader()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize eBPF loader: %w", err)
        }</span>

        // Load egress program (optional)
        <span class="cov0" title="0">if err := ebpfLoader.LoadEgress(); err != nil </span><span class="cov0" title="0">{
                log.Printf("[!] Warning: Failed to load TC egress objects: %v", err)
                log.Printf("[!] TC Egress DLP will be disabled. Main XDP protection still active.")
        }</span>

        // Initialize logger manager
        <span class="cov0" title="0">logManager, err := logger.NewManager(outputMode, elkConfig, dashboardChan)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize logger manager: %w", err)
        }</span>

        <span class="cov0" title="0">agent := &amp;Agent{
                ebpfLoader:  ebpfLoader,
                iface:       iface,
                ifaceName:   ifaceName,
                logChan:     logManager.LogChannel(),
                logManager:  logManager,
                spaConfig:   spaConfig,
                staticToken: staticToken,
        }

        return agent, nil</span>
}

// Start initializes and starts the agent
func (a *Agent) Start() error <span class="cov0" title="0">{
        // Attach XDP
        _, err := a.ebpfLoader.AttachXDP(a.iface.Index)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to attach XDP: %w", err)
        }</span>
        // Note: XDP link is stored in ebpfLoader and will be closed via ebpfLoader.Close()

        <span class="cov0" title="0">log.Printf("[*] XDP attached to interface: %s (index: %d)", a.ifaceName, a.iface.Index)
        a.logChan &lt;- fmt.Sprintf("[SYSTEM] XDP attached to interface: %s (index: %d)", a.ifaceName, a.iface.Index)

        // Attach TC Egress (if loaded)
        if a.ebpfLoader.EgressObjs != nil </span><span class="cov0" title="0">{
                if err := a.attachTCEgress(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[!] Warning: Failed to attach TC egress: %v", err)
                        log.Printf("[!] TC Egress DLP will be disabled. Main XDP protection still active.")
                }</span> else<span class="cov0" title="0"> {
                        a.logChan &lt;- "[SYSTEM] TC Egress Hook attached (DLP Active)"
                }</span>
        }

        // Start SPA Manager
        <span class="cov0" title="0">spaWrapper := spa.NewWrapper(
                a.ebpfLoader.PhantomObjs.SpaAuthSuccess,
                a.ebpfLoader.PhantomObjs.SpaAuthFailed,
        )
        a.spaManager = spa.NewManager(spaWrapper, a.logChan, config.SPAWhitelistDuration)
        go a.spaManager.Start()

        // Initialize SPA handler
        if a.spaConfig != nil &amp;&amp; a.spaConfig.Mode != config.SPAModeStatic </span><span class="cov0" title="0">{
                // Dynamic SPA mode
                if err := a.initDynamicSPA(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[!] Warning: Failed to initialize dynamic SPA: %v", err)
                        log.Printf("[!] Falling back to static SPA mode")
                }</span>
        } else<span class="cov0" title="0"> {
                // Static SPA mode - initialize handler with static token
                log.Printf("[SPA] Initializing static SPA handler...")
                if err := a.initStaticSPA(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[!] Warning: Failed to initialize static SPA handler: %v", err)
                        a.logChan &lt;- fmt.Sprintf("[!] Warning: Failed to initialize static SPA handler: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("[SPA] Static SPA handler initialized successfully")
                }</span>
        }

        // Log system info
        <span class="cov0" title="0">a.logChan &lt;- fmt.Sprintf("[SYSTEM] SPA Magic Packet port: %d", config.SPAMagicPort)
        a.logChan &lt;- fmt.Sprintf("[SYSTEM] SSH port %d protected - requires SPA whitelist", config.SSHPort)

        // Log interface IP addresses
        addrs, err := a.iface.Addrs()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[DEBUG] Failed to get interface addresses: %v", err)
        }</span> else<span class="cov0" title="0"> {
                for _, addr := range addrs </span><span class="cov0" title="0">{
                        a.logChan &lt;- fmt.Sprintf("[DEBUG] Interface %s has IP: %s", a.ifaceName, addr.String())
                }</span>
        }

        // Warn if using loopback interface
        <span class="cov0" title="0">if a.ifaceName == "lo" </span><span class="cov0" title="0">{
                a.logChan &lt;- "[!] WARNING: XDP attached to LOOPBACK interface!"
                a.logChan &lt;- "[!] WARNING: Traffic from external hosts (Kali) will NOT be captured!"
                a.logChan &lt;- "[!] WARNING: For VMware NAT, ensure XDP attaches to external interface (ens33, eth0, etc.)"
                a.logChan &lt;- "[!] WARNING: Check if interface detection is working correctly"
        }</span>

        // Start Honeypot
        <span class="cov0" title="0">a.honeypot = honeypot.New(a.logChan)
        honeypotErrChan := make(chan error, 1)
        go func() </span><span class="cov0" title="0">{
                if err := a.honeypot.Start(); err != nil </span><span class="cov0" title="0">{
                        honeypotErrChan &lt;- err
                        log.Printf("[!] Failed to start honeypot: %v", err)
                }</span>
        }()

        // Check if honeypot started successfully (non-blocking)
        <span class="cov0" title="0">select </span>{
        case err := &lt;-honeypotErrChan:<span class="cov0" title="0">
                return fmt.Errorf("honeypot failed to start: %w", err)</span>
        default:<span class="cov0" title="0"></span>
                // Honeypot started successfully
        }

        <span class="cov0" title="0">return nil</span>
}

// initDynamicSPA initializes dynamic SPA handler and loads configuration
func (a *Agent) initDynamicSPA() error <span class="cov0" title="0">{
        // Create verifier
        verifier := spa.NewVerifier(a.spaConfig)

        // Note: For now, we use the existing whitelist map
        // In a full implementation, we would need access to the dynamic SPA maps
        // This requires the dynamic SPA eBPF program (phantom_spa_dynamic.c) to be loaded
        // For now, we'll create a simplified map loader using existing maps
        
        // Create map loader (using existing maps as placeholders)
        // Note: Dynamic SPA eBPF program (phantom_spa_dynamic.c) is not yet fully integrated.
        // The dynamic SPA program needs to be compiled and loaded separately.
        // For now, we use the existing whitelist map from the main phantom program.
        mapLoader := spa.NewMapLoader(
                a.ebpfLoader.PhantomObjs.SpaWhitelist, // whitelist map
                nil, // replay map (from dynamic SPA program - not available yet)
                nil, // totp secret map (from dynamic SPA program - not available yet)
                nil, // hmac secret map (from dynamic SPA program - not available yet)
                nil, // config map (from dynamic SPA program - not available yet)
        )

        // Load configuration (if maps are available)
        if mapLoader != nil </span><span class="cov0" title="0">{
                if err := mapLoader.LoadConfiguration(a.spaConfig); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[!] Warning: Failed to load SPA config into maps: %v", err)
                }</span>
        }

        // Create and start handler (static token not needed for dynamic mode)
        <span class="cov0" title="0">handler := spa.NewHandler(verifier, mapLoader, a.logChan, a.spaConfig, "")
        if err := handler.Start(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start SPA handler: %w", err)
        }</span>

        <span class="cov0" title="0">a.spaHandler = handler
        a.logChan &lt;- fmt.Sprintf("[SPA] Dynamic SPA initialized (mode: %s)", a.spaConfig.Mode)

        return nil</span>
}

// initStaticSPA initializes static SPA handler with configurable token
func (a *Agent) initStaticSPA() error <span class="cov0" title="0">{
        // Create a minimal config for static mode
        staticConfig := config.DefaultDynamicSPAConfig()
        staticConfig.Mode = config.SPAModeStatic

        // Create verifier (not really used for static mode, but required by handler)
        verifier := spa.NewVerifier(staticConfig)

        // Create map loader (using existing whitelist map)
        mapLoader := spa.NewMapLoader(
                a.ebpfLoader.PhantomObjs.SpaWhitelist,
                nil, nil, nil, nil, // Dynamic SPA maps not needed for static mode
        )

        // Create and start handler with static token
        handler := spa.NewHandler(verifier, mapLoader, a.logChan, staticConfig, a.staticToken)
        if err := handler.Start(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start static SPA handler: %w", err)
        }</span>

        <span class="cov0" title="0">a.spaHandler = handler
        if a.staticToken != "" &amp;&amp; a.staticToken != config.SPASecretToken </span><span class="cov0" title="0">{
                a.logChan &lt;- fmt.Sprintf("[SPA] Static SPA initialized with custom token (length: %d)", len(a.staticToken))
                log.Printf("[SPA] Static SPA initialized with custom token (length: %d)", len(a.staticToken))
        }</span> else<span class="cov0" title="0"> {
                a.logChan &lt;- fmt.Sprintf("[SPA] Static SPA initialized with default token")
                log.Printf("[SPA] Static SPA initialized with default token: %s", config.SPASecretToken)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// attachTCEgress attaches TC egress program using netlink
func (a *Agent) attachTCEgress() error <span class="cov0" title="0">{
        _, err := netlink.LinkByIndex(a.iface.Index)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not get link: %w", err)
        }</span>

        // Add clsact qdisc
        <span class="cov0" title="0">qdisc := &amp;netlink.GenericQdisc{
                QdiscAttrs: netlink.QdiscAttrs{
                        LinkIndex: a.iface.Index,
                        Handle:    netlink.MakeHandle(0xffff, 0),
                        Parent:    netlink.HANDLE_CLSACT,
                },
                QdiscType: "clsact",
        }

        if err := netlink.QdiscAdd(qdisc); err != nil &amp;&amp; !isExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add qdisc: %w", err)
        }</span>

        // Add BPF Filter to Egress
        <span class="cov0" title="0">filter := &amp;netlink.BpfFilter{
                FilterAttrs: netlink.FilterAttrs{
                        LinkIndex: a.iface.Index,
                        Parent:    netlink.HANDLE_MIN_EGRESS,
                        Handle:    1,
                        Protocol:  unix.ETH_P_ALL,
                        Priority:  1,
                },
                Fd:           a.ebpfLoader.EgressObjs.PhantomEgressProg.FD(),
                Name:         "phantom_egress",
                DirectAction: true,
        }

        if err := netlink.FilterAdd(filter); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add filter: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func isExist(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return os.IsExist(err)</span>
}

// GetEBPFObjects returns eBPF objects for dashboard
func (a *Agent) GetEBPFObjects() (*ebpf.PhantomObjects, *ebpf.EgressObjects) <span class="cov0" title="0">{
        return a.ebpfLoader.PhantomObjs, a.ebpfLoader.EgressObjs
}</span>

// GetInterfaceName returns the interface name
func (a *Agent) GetInterfaceName() string <span class="cov0" title="0">{
        return a.ifaceName
}</span>

// Close cleans up agent resources
func (a *Agent) Close() error <span class="cov0" title="0">{
        if a.spaHandler != nil </span><span class="cov0" title="0">{
                if err := a.spaHandler.Stop(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">if a.honeypot != nil </span><span class="cov0" title="0">{
                if err := a.honeypot.Close(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">if a.logManager != nil </span><span class="cov0" title="0">{
                if err := a.logManager.Close(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">if a.ebpfLoader != nil </span><span class="cov0" title="0">{
                return a.ebpfLoader.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package config

// SPA Configuration
const (
        SPAMagicPort         = 1337
        SPASecretToken       = "PHANTOM_GRID_SPA_2025"
        SPATokenLen          = 21
        SPAWhitelistDuration = 30
)

// Network Configuration
const (
        HoneypotPort = 9999
        SSHPort      = 22
)

// CriticalPorts are ports protected by Phantom Protocol (SPA required)
// These ports will be DROPPED unless IP is whitelisted via SPA Magic Packet
// IMPORTANT: This is auto-generated from CriticalPortDefinitions in ports.go
// To add/modify ports, update CriticalPortDefinitions in ports.go and run: make generate-config
var CriticalPorts = GetCriticalPorts()

// FakePorts are ports for honeypot deception (The Mirage)
// IMPORTANT: This is auto-generated from FakePortDefinitions in ports.go
// To add/modify ports, update FakePortDefinitions in ports.go and run: make generate-config
var FakePorts = GetFakePorts()

// Fallback ports if honeypot port is unavailable
var FallbackPorts = []int{9998, 9997, 9996, 8888, 7777}

// OutputMode defines where logs and events are sent
type OutputMode string

const (
        OutputModeDashboard OutputMode = "dashboard" // Terminal dashboard only
        OutputModeELK       OutputMode = "elk"       // Elasticsearch only
        OutputModeBoth      OutputMode = "both"      // Both dashboard and ELK
)

// ELKConfiguration holds Elasticsearch connection settings
type ELKConfiguration struct {
        Enabled       bool
        Addresses     []string // Elasticsearch addresses (e.g., ["http://localhost:9200"])
        Index         string   // Index name (default: "phantom-grid")
        Username      string   // Optional: Basic auth username
        Password      string   // Optional: Basic auth password
        UseTLS        bool     // Enable TLS
        SkipVerify    bool     // Skip TLS certificate verification
        BatchSize     int      // Number of documents to batch before sending
        FlushInterval int      // Flush interval in seconds
}

// DefaultELKConfig returns default ELK configuration
func DefaultELKConfig() ELKConfiguration <span class="cov0" title="0">{
        return ELKConfiguration{
                Enabled:       false,
                Addresses:     []string{"http://localhost:9200"},
                Index:         "phantom-grid",
                Username:      "",
                Password:      "",
                UseTLS:        false,
                SkipVerify:    false,
                BatchSize:     100,
                FlushInterval: 5,
        }
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package config

// EBPFConstants holds all eBPF-related constants
// These are used to generate C defines for eBPF programs
type EBFPConstants struct {
        // Core Ports
        HoneypotPort int
        SSHPort      int

        // SPA Configuration
        SPAMagicPort         int
        SPASecretToken       string
        SPATokenLen          int
        SPAWhitelistDuration int // in seconds

        // OS Fingerprint Values (TTL)
        TTLWindows int
        TTLLinux   int
        TTLFreeBSD int
        TTLSolaris int

        // OS Fingerprint Values (Window Size)
        WindowWindows int
        WindowLinux   int
        WindowFreeBSD int

        // Egress DLP
        MaxPayloadScan int
}

// GetEBPFConstants returns all eBPF constants
func GetEBPFConstants() EBFPConstants <span class="cov0" title="0">{
        return EBFPConstants{
                HoneypotPort:         HoneypotPort,
                SSHPort:              SSHPort,
                SPAMagicPort:         SPAMagicPort,
                SPASecretToken:       SPASecretToken,
                SPATokenLen:          SPATokenLen,
                SPAWhitelistDuration: SPAWhitelistDuration,
                TTLWindows:           128,
                TTLLinux:             64,
                TTLFreeBSD:           64,
                TTLSolaris:           255,
                WindowWindows:        65535,
                WindowLinux:          29200,
                WindowFreeBSD:        65535,
                MaxPayloadScan:       512,
        }
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package config

import "fmt"

// PortDefinition represents a port with metadata
type PortDefinition struct {
        Port        int
        Name        string
        Description string
        Category    string
        Alias       string // For generating C macro name
}

// PortCategory groups ports by purpose
const (
        CategoryCore        = "core"
        CategoryDatabase    = "database"
        CategoryAdmin       = "admin"
        CategoryRemote      = "remote"
        CategoryContainer   = "container"
        CategoryApplication = "application"
        CategoryDirectory   = "directory"
        CategoryCache       = "cache"
        CategoryFile        = "file"
        CategoryMessaging   = "messaging"
)

// CriticalPortDefinitions is the single source of truth for protected ports
// This list is used to generate both Go config and eBPF C code
var CriticalPortDefinitions = []PortDefinition{
        // Core Services - Only FTP and SSH are protected
        {21, "FTP", "File Transfer Protocol", CategoryFile, "FTP_PORT"},
        {22, "SSH", "Secure Shell", CategoryCore, "SSH_PORT"},
}

// FakePortDefinitions defines ports for honeypot deception
var FakePortDefinitions = []PortDefinition{
        {80, "HTTP", "HTTP Web Server", CategoryApplication, "HTTP_PORT"},
        {443, "HTTPS", "HTTPS Web Server", CategoryApplication, "HTTPS_PORT"},
        {3306, "MySQL Fake", "MySQL (fake honeypot)", CategoryDatabase, "MYSQL_FAKE_PORT"},
        {5432, "PostgreSQL Fake", "PostgreSQL (fake honeypot)", CategoryDatabase, "POSTGRES_FAKE_PORT"},
        {6379, "Redis Fake", "Redis (fake honeypot)", CategoryDatabase, "REDIS_FAKE_PORT"},
        {27017, "MongoDB Fake", "MongoDB (fake honeypot)", CategoryDatabase, "MONGODB_FAKE_PORT"},
        {8080, "Admin Panel Fake", "Admin Panel (fake)", CategoryAdmin, "ADMIN_PANEL_FAKE_PORT"},
        {8443, "HTTPS Alt Fake", "HTTPS Alternative (fake)", CategoryAdmin, "HTTPS_ALT_FAKE_PORT"},
        {9000, "Admin Panel Fake 2", "Admin Panel (fake)", CategoryAdmin, "ADMIN_PANEL_FAKE_PORT_2"},
        {21, "FTP", "FTP Server", CategoryFile, "FTP_PORT"},
        {23, "Telnet", "Telnet Server", CategoryRemote, "TELNET_PORT"},
        {3389, "RDP Fake", "RDP (fake honeypot)", CategoryRemote, "RDP_FAKE_PORT"},
        {5900, "VNC", "VNC Server", CategoryRemote, "VNC_PORT"},
        {1433, "MSSQL Fake", "MSSQL (fake honeypot)", CategoryDatabase, "MSSQL_FAKE_PORT"},
        {1521, "Oracle Fake", "Oracle (fake honeypot)", CategoryDatabase, "ORACLE_FAKE_PORT"},
        {5433, "PostgreSQL Alt Fake", "PostgreSQL Alternative (fake)", CategoryDatabase, "POSTGRES_ALT_FAKE_PORT"},
        {11211, "Memcached Fake", "Memcached (fake)", CategoryCache, "MEMCACHED_FAKE_PORT"},
        {27018, "MongoDB Shard Fake", "MongoDB Shard (fake)", CategoryDatabase, "MONGODB_SHARD_FAKE_PORT"},
        {9200, "Elasticsearch Fake", "Elasticsearch (fake)", CategoryAdmin, "ELASTICSEARCH_FAKE_PORT"},
        {5601, "Kibana Fake", "Kibana (fake)", CategoryAdmin, "KIBANA_FAKE_PORT"},
        {3000, "Node.js Fake", "Node.js (fake)", CategoryApplication, "NODEJS_FAKE_PORT"},
        {5000, "Flask Fake", "Flask (fake)", CategoryApplication, "FLASK_FAKE_PORT"},
        {8000, "Django Fake", "Django (fake)", CategoryApplication, "DJANGO_FAKE_PORT"},
        {8888, "Jupyter Fake", "Jupyter (fake)", CategoryApplication, "JUPYTER_FAKE_PORT"},
}

// GetCriticalPorts returns list of critical port numbers
func GetCriticalPorts() []int <span class="cov8" title="1">{
        ports := make([]int, len(CriticalPortDefinitions))
        for i, def := range CriticalPortDefinitions </span><span class="cov8" title="1">{
                ports[i] = def.Port
        }</span>
        <span class="cov8" title="1">return ports</span>
}

// GetFakePorts returns list of fake port numbers
func GetFakePorts() []int <span class="cov8" title="1">{
        ports := make([]int, len(FakePortDefinitions))
        for i, def := range FakePortDefinitions </span><span class="cov8" title="1">{
                ports[i] = def.Port
        }</span>
        <span class="cov8" title="1">return ports</span>
}

// FindPortDefinition finds a port definition by port number
func FindPortDefinition(port int) *PortDefinition <span class="cov8" title="1">{
        for i := range CriticalPortDefinitions </span><span class="cov8" title="1">{
                if CriticalPortDefinitions[i].Port == port </span><span class="cov8" title="1">{
                        return &amp;CriticalPortDefinitions[i]
                }</span>
        }
        <span class="cov8" title="1">for i := range FakePortDefinitions </span><span class="cov8" title="1">{
                if FakePortDefinitions[i].Port == port </span><span class="cov8" title="1">{
                        return &amp;FakePortDefinitions[i]
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// ValidatePorts validates port configuration for consistency
func ValidatePorts() error <span class="cov8" title="1">{
        // Check for duplicates in critical ports
        seen := make(map[int]bool)
        for _, def := range CriticalPortDefinitions </span><span class="cov8" title="1">{
                if seen[def.Port] </span><span class="cov0" title="0">{
                        return fmt.Errorf("duplicate critical port: %d (%s)", def.Port, def.Name)
                }</span>
                <span class="cov8" title="1">seen[def.Port] = true</span>
        }

        // Check port ranges
        <span class="cov8" title="1">for _, def := range CriticalPortDefinitions </span><span class="cov8" title="1">{
                if def.Port &lt; 1 || def.Port &gt; 65535 </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid port range: %d (%s)", def.Port, def.Name)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package config

import (
        "bytes"
        "crypto/ed25519"
        "crypto/rand"
        "fmt"
        "os"
        "path/filepath"
)

// SPAMode defines the SPA authentication mode
type SPAMode string

const (
        SPAModeStatic    SPAMode = "static"    // Legacy static token (backward compatible)
        SPAModeDynamic   SPAMode = "dynamic"  // Dynamic SPA with TOTP + HMAC
        SPAModeAsymmetric SPAMode = "asymmetric" // Dynamic SPA with TOTP + Ed25519 (recommended)
)

// DynamicSPAConfig holds configuration for dynamic SPA
type DynamicSPAConfig struct {
        Mode SPAMode // SPA authentication mode

        // TOTP Configuration
        TOTPTimeStep    int    // Time step in seconds (default: 30)
        TOTPTolerance   int    // Time tolerance in steps (default: 1, allows ±30s)
        TOTPSecret      []byte // Shared secret for TOTP (32 bytes recommended)

        // Ed25519 Configuration (for asymmetric mode)
        PublicKey  ed25519.PublicKey  // Server public key (32 bytes)
        PrivateKey ed25519.PrivateKey // Client private key (64 bytes) - only for key generation

        // HMAC Configuration (for dynamic mode)
        HMACSecret []byte // Shared secret for HMAC-SHA256 (32 bytes)

        // Anti-Replay Configuration
        ReplayWindowSeconds int // Replay protection window (default: 60)
        MaxReplayEntries    int // Maximum replay entries in LRU map (default: 1000)

        // Packet Obfuscation
        EnableObfuscation bool // Enable binary packet obfuscation
        ObfuscationKey    []byte // Key for packet obfuscation (optional)
}

// DefaultDynamicSPAConfig returns default dynamic SPA configuration
func DefaultDynamicSPAConfig() *DynamicSPAConfig <span class="cov0" title="0">{
        // Generate default TOTP secret
        totpSecret := make([]byte, 32)
        if _, err := rand.Read(totpSecret); err != nil </span><span class="cov0" title="0">{
                // Fallback to default secret
                totpSecret = []byte("PHANTOM_GRID_TOTP_SECRET_2025_DEFAULT")
        }</span>

        <span class="cov0" title="0">return &amp;DynamicSPAConfig{
                Mode:               SPAModeAsymmetric,
                TOTPTimeStep:       30,
                TOTPTolerance:      1,
                TOTPSecret:         totpSecret,
                ReplayWindowSeconds: 60,
                MaxReplayEntries:    1000,
                EnableObfuscation:   true,
        }</span>
}

// GenerateEd25519Keys generates a new Ed25519 key pair
func GenerateEd25519Keys() (ed25519.PublicKey, ed25519.PrivateKey, error) <span class="cov0" title="0">{
        return ed25519.GenerateKey(rand.Reader)
}</span>

// LoadKeysFromFile loads Ed25519 keys from files
// If publicKeyPath is empty, only private key will be loaded
// If privateKeyPath is empty, only public key will be loaded
func LoadKeysFromFile(publicKeyPath, privateKeyPath string) (ed25519.PublicKey, ed25519.PrivateKey, error) <span class="cov0" title="0">{
        var publicKey ed25519.PublicKey
        var privateKey ed25519.PrivateKey

        // Load public key if path is provided
        if publicKeyPath != "" </span><span class="cov0" title="0">{
                publicKeyData, err := os.ReadFile(publicKeyPath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("failed to read public key: %w", err)
                }</span>
                // Remove any whitespace/newlines
                <span class="cov0" title="0">publicKeyData = bytes.TrimSpace(publicKeyData)
                if len(publicKeyData) != ed25519.PublicKeySize </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("invalid public key size: expected %d, got %d", ed25519.PublicKeySize, len(publicKeyData))
                }</span>
                <span class="cov0" title="0">publicKey = ed25519.PublicKey(publicKeyData)</span>
        }

        // Load private key if path is provided
        <span class="cov0" title="0">if privateKeyPath != "" </span><span class="cov0" title="0">{
                privateKeyData, err := os.ReadFile(privateKeyPath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("failed to read private key: %w", err)
                }</span>
                // Remove any whitespace/newlines
                <span class="cov0" title="0">privateKeyData = bytes.TrimSpace(privateKeyData)
                if len(privateKeyData) != ed25519.PrivateKeySize </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("invalid private key size: expected %d, got %d", ed25519.PrivateKeySize, len(privateKeyData))
                }</span>
                <span class="cov0" title="0">privateKey = ed25519.PrivateKey(privateKeyData)

                // If public key was not loaded, derive it from private key
                if publicKey == nil </span><span class="cov0" title="0">{
                        publicKey = privateKey.Public().(ed25519.PublicKey)
                }</span>
        }

        // At least one key must be loaded
        <span class="cov0" title="0">if publicKey == nil &amp;&amp; privateKey == nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("at least one key path must be provided")
        }</span>

        <span class="cov0" title="0">return publicKey, privateKey, nil</span>
}

// LoadPrivateKeyFromFile loads only the private key from a file
// This is a convenience function for clients that only need the private key
func LoadPrivateKeyFromFile(privateKeyPath string) (ed25519.PrivateKey, error) <span class="cov0" title="0">{
        _, privateKey, err := LoadKeysFromFile("", privateKeyPath)
        return privateKey, err
}</span>

// SaveKeysToFile saves Ed25519 keys to files
func SaveKeysToFile(publicKey ed25519.PublicKey, privateKey ed25519.PrivateKey, keyDir string) error <span class="cov0" title="0">{
        if err := os.MkdirAll(keyDir, 0700); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create key directory: %w", err)
        }</span>

        <span class="cov0" title="0">publicKeyPath := filepath.Join(keyDir, "spa_public.key")
        privateKeyPath := filepath.Join(keyDir, "spa_private.key")

        if err := os.WriteFile(publicKeyPath, publicKey, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write public key: %w", err)
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(privateKeyPath, privateKey, 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write private key: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetSPAMode returns the current SPA mode
func GetSPAMode() SPAMode <span class="cov0" title="0">{
        // Check environment variable first
        if mode := os.Getenv("SPA_MODE"); mode != "" </span><span class="cov0" title="0">{
                switch SPAMode(mode) </span>{
                case SPAModeStatic, SPAModeDynamic, SPAModeAsymmetric:<span class="cov0" title="0">
                        return SPAMode(mode)</span>
                }
        }
        // Default to asymmetric for new installations
        <span class="cov0" title="0">return SPAModeAsymmetric</span>
}


</pre>
		
		<pre class="file" id="file11" style="display: none">package dashboard

import (
        "fmt"
        "strings"
        "sync"
        "time"

        ui "github.com/gizak/termui/v3"

        "phantom-grid/internal/ebpf"
)

// Dashboard manages the TUI dashboard
type Dashboard struct {
        phantomObjs  *ebpf.PhantomObjects
        egressObjs   *ebpf.EgressObjects
        iface        string
        startTime    time.Time
        statsMutex   sync.RWMutex
        honeypotConns uint64
        activeSessions uint64
        totalCommands  uint64
        logChan       &lt;-chan string
}

// New creates a new Dashboard instance
func New(iface string, phantomObjs *ebpf.PhantomObjects, egressObjs *ebpf.EgressObjects, logChan &lt;-chan string) *Dashboard <span class="cov0" title="0">{
        return &amp;Dashboard{
                phantomObjs: phantomObjs,
                egressObjs:  egressObjs,
                iface:       iface,
                startTime:   time.Now(),
                logChan:     logChan,
        }
}</span>

// Start initializes and runs the dashboard
func (d *Dashboard) Start() <span class="cov0" title="0">{
        if err := ui.Init(); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("failed to initialize termui: %v", err))</span>
        }
        <span class="cov0" title="0">defer ui.Close()

        termWidth, termHeight := ui.TerminalDimensions()
        if termWidth &lt; 100 </span><span class="cov0" title="0">{
                termWidth = 100
        }</span>
        <span class="cov0" title="0">if termHeight &lt; 30 </span><span class="cov0" title="0">{
                termHeight = 30
        }</span>

        <span class="cov0" title="0">widgets := d.createWidgets(termWidth, termHeight)
        d.runEventLoop(widgets)</span>
}

// ProcessLogMessage processes a log message and updates statistics
func (d *Dashboard) ProcessLogMessage(msg string) <span class="cov0" title="0">{
        d.statsMutex.Lock()
        if strings.Contains(msg, "TRAP HIT") </span><span class="cov0" title="0">{
                d.honeypotConns++
                d.activeSessions++
        }</span>
        <span class="cov0" title="0">if strings.Contains(msg, "COMMAND") </span><span class="cov0" title="0">{
                d.totalCommands++
        }</span>
        <span class="cov0" title="0">if strings.Contains(msg, "exit") </span><span class="cov0" title="0">{
                if d.activeSessions &gt; 0 </span><span class="cov0" title="0">{
                        d.activeSessions--
                }</span>
        }
        <span class="cov0" title="0">d.statsMutex.Unlock()</span>
}

</pre>
		
		<pre class="file" id="file12" style="display: none">package dashboard

import (
        "fmt"
        "time"

        ui         "github.com/gizak/termui/v3"
)

// runEventLoop runs the main dashboard event loop
func (d *Dashboard) runEventLoop(w *DashboardWidgets) <span class="cov0" title="0">{
        // Initial render
        ui.Render(w.header, w.logList, w.gauge, w.redirectedBox, w.stealthBox, w.egressBox,
                w.osMutationsBox, w.spaSuccessBox, w.spaFailedBox, w.systemInfoBox, w.connStatsBox, w.footer)

        ticker := time.NewTicker(200 * time.Millisecond)
        statsTicker := time.NewTicker(1 * time.Second)
        uptimeTicker := time.NewTicker(1 * time.Second)
        uiEvents := ui.PollEvents()
        paused := false
        autoScroll := true
        var lastAttackCount uint64 = 0

        // Update uptime
        go func() </span><span class="cov0" title="0">{
                for range uptimeTicker.C </span><span class="cov0" title="0">{
                        uptime := time.Since(d.startTime)
                        hours := int(uptime.Hours())
                        minutes := int(uptime.Minutes()) % 60
                        seconds := int(uptime.Seconds()) % 60
                        w.header.Text = fmt.Sprintf("STATUS: [ACTIVE](fg:green,mod:bold) | INTERFACE: [%s](fg:yellow) | MODE: [eBPF KERNEL TRAP](fg:red) | UPTIME: [%02d:%02d:%02d](fg:cyan)",
                                d.iface, hours, minutes, seconds)
                        ui.Render(w.header)
                }</span>
        }()

        // Update statistics
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                for range statsTicker.C </span><span class="cov0" title="0">{
                        d.updateStatistics(w, &amp;lastAttackCount)
                }</span>
        }()

        // Main event loop
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case e := &lt;-uiEvents:<span class="cov0" title="0">
                        if e.Type == ui.KeyboardEvent </span><span class="cov0" title="0">{
                                switch e.ID </span>{
                                case "q", "&lt;C-c&gt;":<span class="cov0" title="0">
                                        return</span>
                                case " ":<span class="cov0" title="0">
                                        paused = !paused
                                        msg := "[SYSTEM] Log scrolling paused"
                                        if !paused </span><span class="cov0" title="0">{
                                                msg = "[SYSTEM] Log scrolling resumed"
                                        }</span>
                                        <span class="cov0" title="0">d.handleLogMessage(msg, w, paused, &amp;autoScroll)</span>
                                case "j", "&lt;Down&gt;":<span class="cov0" title="0">
                                        w.logList.ScrollDown()
                                        autoScroll = false
                                        ui.Render(w.logList, w.connStatsBox)</span>
                                case "k", "&lt;Up&gt;":<span class="cov0" title="0">
                                        w.logList.ScrollUp()
                                        autoScroll = false
                                        ui.Render(w.logList, w.connStatsBox)</span>
                                case "g", "&lt;Home&gt;":<span class="cov0" title="0">
                                        w.logList.ScrollTop()
                                        autoScroll = false
                                        ui.Render(w.logList, w.connStatsBox)</span>
                                case "G", "&lt;End&gt;":<span class="cov0" title="0">
                                        w.logList.ScrollBottom()
                                        autoScroll = true
                                        ui.Render(w.logList, w.connStatsBox)</span>
                                case "a":<span class="cov0" title="0">
                                        autoScroll = !autoScroll
                                        msg := "[SYSTEM] Auto-scroll disabled (press 'a' to enable, 'G' to go to bottom)"
                                        if autoScroll </span><span class="cov0" title="0">{
                                                w.logList.ScrollBottom()
                                                msg = "[SYSTEM] Auto-scroll enabled (press 'a' to disable)"
                                        }</span>
                                        <span class="cov0" title="0">d.handleLogMessage(msg, w, paused, &amp;autoScroll)
                                        ui.Render(w.logList, w.connStatsBox)</span>
                                }
                        }
                case msg := &lt;-d.logChan:<span class="cov0" title="0">
                        d.handleLogMessage(msg, w, paused, &amp;autoScroll)</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        ui.Render(w.logList, w.connStatsBox)</span>
                }
        }
}

// updateStatistics updates all dashboard statistics
func (d *Dashboard) updateStatistics(w *DashboardWidgets, lastAttackCount *uint64) <span class="cov0" title="0">{
        var attackKey uint32 = 0
        var attackVal uint64
        if err := d.phantomObjs.AttackStats.Lookup(attackKey, &amp;attackVal); err == nil </span><span class="cov0" title="0">{
                w.redirectedBox.Text = fmt.Sprintf("\n\n   %d", attackVal)

                if attackVal &gt; *lastAttackCount </span><span class="cov0" title="0">{
                        *lastAttackCount = attackVal
                }</span>
        }

        <span class="cov0" title="0">var stealthKey uint32 = 0
        var stealthVal uint64
        if err := d.phantomObjs.StealthDrops.Lookup(stealthKey, &amp;stealthVal); err == nil </span><span class="cov0" title="0">{
                w.stealthBox.Text = fmt.Sprintf("\n\n   %d", stealthVal)
        }</span>

        <span class="cov0" title="0">var osKey uint32 = 0
        var osVal uint64
        if err := d.phantomObjs.OsMutations.Lookup(osKey, &amp;osVal); err == nil </span><span class="cov0" title="0">{
                w.osMutationsBox.Text = fmt.Sprintf("\n\n   %d", osVal)
        }</span>

        <span class="cov0" title="0">var spaSuccessKey uint32 = 0
        var spaSuccessVal uint64
        if err := d.phantomObjs.SpaAuthSuccess.Lookup(spaSuccessKey, &amp;spaSuccessVal); err == nil </span><span class="cov0" title="0">{
                w.spaSuccessBox.Text = fmt.Sprintf("\n\n   %d", spaSuccessVal)
        }</span>

        <span class="cov0" title="0">var spaFailedKey uint32 = 0
        var spaFailedVal uint64
        if err := d.phantomObjs.SpaAuthFailed.Lookup(spaFailedKey, &amp;spaFailedVal); err == nil </span><span class="cov0" title="0">{
                w.spaFailedBox.Text = fmt.Sprintf("\n\n   %d", spaFailedVal)
        }</span>

        <span class="cov0" title="0">if d.egressObjs != nil &amp;&amp; d.egressObjs.EgressBlocks != nil </span><span class="cov0" title="0">{
                var egressKey uint32 = 0
                var egressVal uint64
                if err := d.egressObjs.EgressBlocks.Lookup(egressKey, &amp;egressVal); err == nil </span><span class="cov0" title="0">{
                        w.egressBox.Text = fmt.Sprintf("\n\n   %d", egressVal)
                }</span>
        }

        // Update connection statistics
        <span class="cov0" title="0">d.statsMutex.RLock()
        connCount := d.honeypotConns
        sessionCount := d.activeSessions
        cmdCount := d.totalCommands
        d.statsMutex.RUnlock()

        w.connStatsBox.Text = fmt.Sprintf("\n\nHoneypot Connections: %d\nActive Sessions: %d\nTotal Commands: %d",
                connCount, sessionCount, cmdCount)

        // Calculate threat level
        totalThreats := attackVal + stealthVal
        if totalThreats &gt; 0 </span><span class="cov0" title="0">{
                threatLevel := int((totalThreats * 10) % 100)
                if threatLevel &gt; 100 </span><span class="cov0" title="0">{
                        threatLevel = 100
                }</span>
                <span class="cov0" title="0">w.gauge.Percent = threatLevel
                if threatLevel &lt; 30 </span><span class="cov0" title="0">{
                        w.gauge.BarColor = ui.ColorGreen
                        w.gauge.Label = fmt.Sprintf("%d%% - LOW", threatLevel)
                }</span> else<span class="cov0" title="0"> if threatLevel &lt; 70 </span><span class="cov0" title="0">{
                        w.gauge.BarColor = ui.ColorYellow
                        w.gauge.Label = fmt.Sprintf("%d%% - MEDIUM", threatLevel)
                }</span> else<span class="cov0" title="0"> {
                        w.gauge.BarColor = ui.ColorRed
                        w.gauge.Label = fmt.Sprintf("%d%% - HIGH", threatLevel)
                }</span>
        }

        <span class="cov0" title="0">ui.Render(w.redirectedBox, w.stealthBox, w.egressBox, w.osMutationsBox,
                w.spaSuccessBox, w.spaFailedBox, w.gauge, w.connStatsBox)</span>
}

// handleLogMessage processes log messages and updates UI
func (d *Dashboard) handleLogMessage(msg string, w *DashboardWidgets, paused bool, autoScroll *bool) <span class="cov0" title="0">{
        if !paused </span><span class="cov0" title="0">{
                w.logList.Rows = append(w.logList.Rows, msg)
                maxLogs := 500 // Keep reasonable history
                if len(w.logList.Rows) &gt; maxLogs </span><span class="cov0" title="0">{
                        w.logList.Rows = w.logList.Rows[len(w.logList.Rows)-maxLogs:]
                }</span>
                <span class="cov0" title="0">if *autoScroll </span><span class="cov0" title="0">{
                        w.logList.ScrollBottom()
                }</span>
        }

        // Update statistics
        <span class="cov0" title="0">d.ProcessLogMessage(msg)

        ui.Render(w.logList, w.connStatsBox)</span>
}

</pre>
		
		<pre class="file" id="file13" style="display: none">package dashboard

import (
        "fmt"

        ui "github.com/gizak/termui/v3"
        "github.com/gizak/termui/v3/widgets"

        "phantom-grid/internal/config"
)

// DashboardWidgets holds all UI widgets
type DashboardWidgets struct {
        header        *widgets.Paragraph
        logList       *widgets.List
        gauge         *widgets.Gauge
        redirectedBox *widgets.Paragraph
        stealthBox    *widgets.Paragraph
        egressBox     *widgets.Paragraph
        osMutationsBox *widgets.Paragraph
        spaSuccessBox *widgets.Paragraph
        spaFailedBox  *widgets.Paragraph
        systemInfoBox *widgets.Paragraph
        connStatsBox  *widgets.Paragraph
        footer        *widgets.Paragraph
}

// createWidgets creates and configures all dashboard widgets
func (d *Dashboard) createWidgets(termWidth, termHeight int) *DashboardWidgets <span class="cov0" title="0">{
        w := &amp;DashboardWidgets{}

        // Header
        w.header = widgets.NewParagraph()
        w.header.Title = " ═══ PHANTOM GRID - ACTIVE DEFENSE SYSTEM ═══ "
        w.header.Text = fmt.Sprintf("STATUS: [ACTIVE](fg:green,mod:bold) | INTERFACE: [%s](fg:yellow) | MODE: [eBPF KERNEL TRAP](fg:red) | UPTIME: [00:00:00](fg:cyan)", d.iface)
        w.header.SetRect(0, 0, termWidth, 3)
        w.header.TextStyle.Fg = ui.ColorCyan
        w.header.BorderStyle.Fg = ui.ColorCyan

        // Log list
        w.logList = widgets.NewList()
        w.logList.Title = " ═══ REAL-TIME FORENSICS &amp; EVENT LOG (j/k: scroll, a: auto-scroll, G: bottom) ═══ "
        w.logList.Rows = []string{
                "[SYSTEM] Phantom Grid initialized...",
                "[SYSTEM] eBPF XDP Hook attached...",
                "[SYSTEM] TC Egress Hook attached (DLP Active)...",
                "[SYSTEM] Honeypot service listening on port 9999...",
                "[SYSTEM] Dashboard ready. Monitoring traffic...",
                "[HELP] Use 'j'/'k' to scroll, 'G' to go to bottom, 'a' to toggle auto-scroll",
        }
        w.logList.SetRect(0, 3, termWidth/2+10, termHeight-8)
        w.logList.TextStyle.Fg = ui.ColorGreen
        w.logList.SelectedRowStyle.Fg = ui.ColorWhite
        w.logList.SelectedRowStyle.Bg = ui.ColorBlue
        w.logList.BorderStyle.Fg = ui.ColorGreen

        // Threat gauge
        w.gauge = widgets.NewGauge()
        w.gauge.Title = " ═══ THREAT LEVEL ═══ "
        w.gauge.Percent = 0
        w.gauge.SetRect(termWidth/2+10, 3, termWidth, 6)
        w.gauge.BarColor = ui.ColorGreen
        w.gauge.Label = "0%"
        w.gauge.BorderStyle.Fg = ui.ColorYellow

        // Statistics boxes
        w.redirectedBox = widgets.NewParagraph()
        w.redirectedBox.Title = " ═══ REDIRECTED TO HONEYPOT ═══ "
        w.redirectedBox.Text = "\n\n       0"
        w.redirectedBox.SetRect(termWidth/2+10, 6, termWidth/2+25, 11)
        w.redirectedBox.TextStyle.Fg = ui.ColorYellow
        w.redirectedBox.BorderStyle.Fg = ui.ColorYellow

        w.stealthBox = widgets.NewParagraph()
        w.stealthBox.Title = " ═══ STEALTH SCAN DROPS ═══ "
        w.stealthBox.Text = "\n\n       0"
        w.stealthBox.SetRect(termWidth/2+25, 6, termWidth/2+40, 11)
        w.stealthBox.TextStyle.Fg = ui.ColorRed
        w.stealthBox.BorderStyle.Fg = ui.ColorRed

        w.egressBox = widgets.NewParagraph()
        w.egressBox.Title = " ═══ EGRESS BLOCKS (DLP) ═══ "
        w.egressBox.Text = "\n\n       0"
        w.egressBox.SetRect(termWidth/2+40, 6, termWidth, 11)
        w.egressBox.TextStyle.Fg = ui.ColorMagenta
        w.egressBox.BorderStyle.Fg = ui.ColorMagenta

        w.osMutationsBox = widgets.NewParagraph()
        w.osMutationsBox.Title = " ═══ OS PERSONALITY MUTATIONS ═══ "
        w.osMutationsBox.Text = "\n\n       0"
        w.osMutationsBox.SetRect(termWidth/2+10, 11, termWidth/2+25, 16)
        w.osMutationsBox.TextStyle.Fg = ui.ColorCyan
        w.osMutationsBox.BorderStyle.Fg = ui.ColorCyan

        w.spaSuccessBox = widgets.NewParagraph()
        w.spaSuccessBox.Title = " ═══ SPA AUTH SUCCESS ═══ "
        w.spaSuccessBox.Text = "\n\n       0"
        w.spaSuccessBox.SetRect(termWidth/2+25, 11, termWidth/2+40, 16)
        w.spaSuccessBox.TextStyle.Fg = ui.ColorGreen
        w.spaSuccessBox.BorderStyle.Fg = ui.ColorGreen

        w.spaFailedBox = widgets.NewParagraph()
        w.spaFailedBox.Title = " ═══ SPA AUTH FAILED ═══ "
        w.spaFailedBox.Text = "\n\n       0"
        w.spaFailedBox.SetRect(termWidth/2+40, 11, termWidth, 16)
        w.spaFailedBox.TextStyle.Fg = ui.ColorRed
        w.spaFailedBox.BorderStyle.Fg = ui.ColorRed

        // System info
        w.systemInfoBox = widgets.NewParagraph()
        w.systemInfoBox.Title = " ═══ SYSTEM INFORMATION ═══ "
        egressStatus := "INACTIVE"
        egressColor := "red"
        if d.egressObjs != nil </span><span class="cov0" title="0">{
                egressStatus = "ACTIVE"
                egressColor = "green"
        }</span>
        <span class="cov0" title="0">w.systemInfoBox.Text = fmt.Sprintf("\nInterface: %s\nXDP Hook: [ACTIVE](fg:green)\nTC Egress: [%s](fg:%s)\nHoneypot: [LISTENING](fg:green)\nPort: %d\nSPA Port: %d\nSSH Port: %d (Protected)",
                d.iface, egressStatus, egressColor, config.HoneypotPort, config.SPAMagicPort, config.SSHPort)
        w.systemInfoBox.SetRect(termWidth/2+10, 16, termWidth, termHeight-8)
        w.systemInfoBox.BorderStyle.Fg = ui.ColorBlue

        // Connection stats
        w.connStatsBox = widgets.NewParagraph()
        w.connStatsBox.Title = " ═══ CONNECTION STATISTICS ═══ "
        w.connStatsBox.Text = "\n\nHoneypot Connections: 0\nActive Sessions: 0\nTotal Commands: 0"
        w.connStatsBox.SetRect(0, termHeight-8, termWidth/2+10, termHeight-3)
        w.connStatsBox.BorderStyle.Fg = ui.ColorMagenta

        // Footer
        w.footer = widgets.NewParagraph()
        w.footer.Title = " CONTROLS "
        w.footer.Text = "Press [q](fg:yellow) or [Ctrl+C](fg:yellow) to exit | [SPACE](fg:yellow) to pause/resume logs"
        w.footer.SetRect(0, termHeight-3, termWidth, termHeight)
        w.footer.BorderStyle.Fg = ui.ColorWhite

        return w</span>
}

</pre>
		
		<pre class="file" id="file14" style="display: none">// Code generated by bpf2go; DO NOT EDIT.
//go:build 386 || amd64 || amd64p32 || arm || arm64 || loong64 || mips64le || mips64p32le || mipsle || ppc64le || riscv64

package ebpf

import (
        "bytes"
        _ "embed"
        "fmt"
        "io"

        "github.com/cilium/ebpf"
)

// LoadEgress returns the embedded CollectionSpec for Egress.
func LoadEgress() (*ebpf.CollectionSpec, error) <span class="cov0" title="0">{
        reader := bytes.NewReader(_EgressBytes)
        spec, err := ebpf.LoadCollectionSpecFromReader(reader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("can't load Egress: %w", err)
        }</span>

        <span class="cov0" title="0">return spec, err</span>
}

// LoadEgressObjects loads Egress and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//        *EgressObjects
//        *EgressPrograms
//        *EgressMaps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func LoadEgressObjects(obj interface{}, opts *ebpf.CollectionOptions) error <span class="cov0" title="0">{
        spec, err := LoadEgress()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return spec.LoadAndAssign(obj, opts)</span>
}

// EgressSpecs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type EgressSpecs struct {
        EgressProgramSpecs
        EgressMapSpecs
}

// EgressSpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type EgressProgramSpecs struct {
        PhantomEgressProg *ebpf.ProgramSpec `ebpf:"phantom_egress_prog"`
}

// EgressMapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type EgressMapSpecs struct {
        EgressBlocks       *ebpf.MapSpec `ebpf:"egress_blocks"`
        SuspiciousPatterns *ebpf.MapSpec `ebpf:"suspicious_patterns"`
}

// EgressObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to LoadEgressObjects or ebpf.CollectionSpec.LoadAndAssign.
type EgressObjects struct {
        EgressPrograms
        EgressMaps
}

func (o *EgressObjects) Close() error <span class="cov0" title="0">{
        return _EgressClose(
                &amp;o.EgressPrograms,
                &amp;o.EgressMaps,
        )
}</span>

// EgressMaps contains all maps after they have been loaded into the kernel.
//
// It can be passed to LoadEgressObjects or ebpf.CollectionSpec.LoadAndAssign.
type EgressMaps struct {
        EgressBlocks       *ebpf.Map `ebpf:"egress_blocks"`
        SuspiciousPatterns *ebpf.Map `ebpf:"suspicious_patterns"`
}

func (m *EgressMaps) Close() error <span class="cov0" title="0">{
        return _EgressClose(
                m.EgressBlocks,
                m.SuspiciousPatterns,
        )
}</span>

// EgressPrograms contains all programs after they have been loaded into the kernel.
//
// It can be passed to LoadEgressObjects or ebpf.CollectionSpec.LoadAndAssign.
type EgressPrograms struct {
        PhantomEgressProg *ebpf.Program `ebpf:"phantom_egress_prog"`
}

func (p *EgressPrograms) Close() error <span class="cov0" title="0">{
        return _EgressClose(
                p.PhantomEgressProg,
        )
}</span>

func _EgressClose(closers ...io.Closer) error <span class="cov0" title="0">{
        for _, closer := range closers </span><span class="cov0" title="0">{
                if err := closer.Close(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Do not access this directly.
//
//go:embed egress_bpfel.o
var _EgressBytes []byte
</pre>
		
		<pre class="file" id="file15" style="display: none">package ebpf

import (
        "fmt"

        "github.com/cilium/ebpf/link"
        "github.com/cilium/ebpf/rlimit"
)

//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -cc clang -cflags "-O2 -g -Wall -Werror" Phantom ./programs/phantom.c
//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -cc clang -cflags "-O2 -g -Wall -Werror" Egress ./programs/phantom_egress.c

// Loader manages eBPF program loading and attachment
type Loader struct {
        PhantomObjs *PhantomObjects
        EgressObjs  *EgressObjects
        xdpLink     link.Link
}

// NewLoader creates a new eBPF loader
func NewLoader() (*Loader, error) <span class="cov0" title="0">{
        if err := rlimit.RemoveMemlock(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to lock memory: %w", err)
        }</span>

        <span class="cov0" title="0">phantomObjs := &amp;PhantomObjects{}
        if err := LoadPhantomObjects(phantomObjs, nil); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load phantom objects: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;Loader{
                PhantomObjs: phantomObjs,
        }, nil</span>
}

// LoadEgress loads the egress eBPF program
func (l *Loader) LoadEgress() error <span class="cov0" title="0">{
        egressObjs := &amp;EgressObjects{}
        if err := LoadEgressObjects(egressObjs, nil); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load egress objects: %w", err)
        }</span>
        <span class="cov0" title="0">l.EgressObjs = egressObjs
        return nil</span>
}

// AttachXDP attaches XDP program to network interface
func (l *Loader) AttachXDP(ifaceIndex int) (link.Link, error) <span class="cov0" title="0">{
        xdpLink, err := link.AttachXDP(link.XDPOptions{
                Program:   l.PhantomObjs.PhantomProg,
                Interface: ifaceIndex,
                Flags:     link.XDPGenericMode,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to attach XDP: %w", err)
        }</span>
        <span class="cov0" title="0">l.xdpLink = xdpLink
        return xdpLink, nil</span>
}

// Close cleans up eBPF resources
func (l *Loader) Close() error <span class="cov0" title="0">{
        if l.xdpLink != nil </span><span class="cov0" title="0">{
                if err := l.xdpLink.Close(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">if l.PhantomObjs != nil </span><span class="cov0" title="0">{
                l.PhantomObjs.Close()
        }</span>
        <span class="cov0" title="0">if l.EgressObjs != nil </span><span class="cov0" title="0">{
                l.EgressObjs.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

</pre>
		
		<pre class="file" id="file16" style="display: none">// Code generated by bpf2go; DO NOT EDIT.
//go:build 386 || amd64 || amd64p32 || arm || arm64 || loong64 || mips64le || mips64p32le || mipsle || ppc64le || riscv64

package ebpf

import (
        "bytes"
        _ "embed"
        "fmt"
        "io"

        "github.com/cilium/ebpf"
)

// LoadPhantom returns the embedded CollectionSpec for Phantom.
func LoadPhantom() (*ebpf.CollectionSpec, error) <span class="cov0" title="0">{
        reader := bytes.NewReader(_PhantomBytes)
        spec, err := ebpf.LoadCollectionSpecFromReader(reader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("can't load Phantom: %w", err)
        }</span>

        <span class="cov0" title="0">return spec, err</span>
}

// LoadPhantomObjects loads Phantom and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//        *PhantomObjects
//        *PhantomPrograms
//        *PhantomMaps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func LoadPhantomObjects(obj interface{}, opts *ebpf.CollectionOptions) error <span class="cov0" title="0">{
        spec, err := LoadPhantom()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return spec.LoadAndAssign(obj, opts)</span>
}

// PhantomSpecs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type PhantomSpecs struct {
        PhantomProgramSpecs
        PhantomMapSpecs
}

// PhantomSpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type PhantomProgramSpecs struct {
        PhantomProg *ebpf.ProgramSpec `ebpf:"phantom_prog"`
}

// PhantomMapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type PhantomMapSpecs struct {
        AttackStats    *ebpf.MapSpec `ebpf:"attack_stats"`
        OsMutations    *ebpf.MapSpec `ebpf:"os_mutations"`
        RedirectMap    *ebpf.MapSpec `ebpf:"redirect_map"`
        SpaAuthFailed  *ebpf.MapSpec `ebpf:"spa_auth_failed"`
        SpaAuthSuccess *ebpf.MapSpec `ebpf:"spa_auth_success"`
        SpaWhitelist   *ebpf.MapSpec `ebpf:"spa_whitelist"`
        StealthDrops   *ebpf.MapSpec `ebpf:"stealth_drops"`
}

// PhantomObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to LoadPhantomObjects or ebpf.CollectionSpec.LoadAndAssign.
type PhantomObjects struct {
        PhantomPrograms
        PhantomMaps
}

func (o *PhantomObjects) Close() error <span class="cov0" title="0">{
        return _PhantomClose(
                &amp;o.PhantomPrograms,
                &amp;o.PhantomMaps,
        )
}</span>

// PhantomMaps contains all maps after they have been loaded into the kernel.
//
// It can be passed to LoadPhantomObjects or ebpf.CollectionSpec.LoadAndAssign.
type PhantomMaps struct {
        AttackStats    *ebpf.Map `ebpf:"attack_stats"`
        OsMutations    *ebpf.Map `ebpf:"os_mutations"`
        RedirectMap    *ebpf.Map `ebpf:"redirect_map"`
        SpaAuthFailed  *ebpf.Map `ebpf:"spa_auth_failed"`
        SpaAuthSuccess *ebpf.Map `ebpf:"spa_auth_success"`
        SpaWhitelist   *ebpf.Map `ebpf:"spa_whitelist"`
        StealthDrops   *ebpf.Map `ebpf:"stealth_drops"`
}

func (m *PhantomMaps) Close() error <span class="cov0" title="0">{
        return _PhantomClose(
                m.AttackStats,
                m.OsMutations,
                m.RedirectMap,
                m.SpaAuthFailed,
                m.SpaAuthSuccess,
                m.SpaWhitelist,
                m.StealthDrops,
        )
}</span>

// PhantomPrograms contains all programs after they have been loaded into the kernel.
//
// It can be passed to LoadPhantomObjects or ebpf.CollectionSpec.LoadAndAssign.
type PhantomPrograms struct {
        PhantomProg *ebpf.Program `ebpf:"phantom_prog"`
}

func (p *PhantomPrograms) Close() error <span class="cov0" title="0">{
        return _PhantomClose(
                p.PhantomProg,
        )
}</span>

func _PhantomClose(closers ...io.Closer) error <span class="cov0" title="0">{
        for _, closer := range closers </span><span class="cov0" title="0">{
                if err := closer.Close(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Do not access this directly.
//
//go:embed phantom_bpfel.o
var _PhantomBytes []byte
</pre>
		
		<pre class="file" id="file17" style="display: none">package exporter

import (
        "bytes"
        "context"
        "crypto/tls"
        "encoding/json"
        "fmt"
        "log"
        "net/http"
        "sync"
        "time"

        "phantom-grid/internal/config"
)

// ELKExporter sends logs to Elasticsearch
type ELKExporter struct {
        config      config.ELKConfiguration
        client      ElasticsearchClient
        buffer      []map[string]interface{}
        bufferMutex sync.Mutex
        ctx         context.Context
        cancel      context.CancelFunc
        wg          sync.WaitGroup
}

// ElasticsearchClient interface for Elasticsearch operations
type ElasticsearchClient interface {
        BulkIndex(index string, documents []map[string]interface{}) error
        Close() error
}

// NewELKExporter creates a new ELK exporter
func NewELKExporter(cfg config.ELKConfiguration) (*ELKExporter, error) <span class="cov0" title="0">{
        if !cfg.Enabled </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ELK exporter is disabled")
        }</span>

        <span class="cov0" title="0">client, err := NewElasticsearchClient(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create Elasticsearch client: %w", err)
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithCancel(context.Background())

        exporter := &amp;ELKExporter{
                config: cfg,
                client: client,
                buffer: make([]map[string]interface{}, 0, cfg.BatchSize),
                ctx:    ctx,
                cancel: cancel,
        }

        // Start background flush goroutine
        exporter.wg.Add(1)
        go exporter.flushLoop()

        return exporter, nil</span>
}

// Export sends a log entry to Elasticsearch (buffered)
func (e *ELKExporter) Export(event map[string]interface{}) error <span class="cov0" title="0">{
        if !e.config.Enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">e.bufferMutex.Lock()
        defer e.bufferMutex.Unlock()

        // Add timestamp if not present
        if _, ok := event["@timestamp"]; !ok </span><span class="cov0" title="0">{
                event["@timestamp"] = time.Now().UTC().Format(time.RFC3339)
        }</span>

        <span class="cov0" title="0">e.buffer = append(e.buffer, event)

        // Flush if buffer is full
        if len(e.buffer) &gt;= e.config.BatchSize </span><span class="cov0" title="0">{
                return e.flushLocked()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// flushLocked flushes the buffer (must be called with bufferMutex locked)
func (e *ELKExporter) flushLocked() error <span class="cov0" title="0">{
        if len(e.buffer) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Copy buffer and clear
        <span class="cov0" title="0">toSend := make([]map[string]interface{}, len(e.buffer))
        copy(toSend, e.buffer)
        e.buffer = e.buffer[:0]

        // Unlock before network call
        e.bufferMutex.Unlock()

        // Send to Elasticsearch
        err := e.client.BulkIndex(e.config.Index, toSend)

        // Re-lock
        e.bufferMutex.Lock()

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[ELK] Failed to send batch: %v", err)
                // Re-add failed documents to buffer (simple retry)
                e.buffer = append(toSend, e.buffer...)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Flush flushes the buffer immediately
func (e *ELKExporter) Flush() error <span class="cov0" title="0">{
        e.bufferMutex.Lock()
        defer e.bufferMutex.Unlock()
        return e.flushLocked()
}</span>

// flushLoop periodically flushes the buffer
func (e *ELKExporter) flushLoop() <span class="cov0" title="0">{
        defer e.wg.Done()

        ticker := time.NewTicker(time.Duration(e.config.FlushInterval) * time.Second)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-e.ctx.Done():<span class="cov0" title="0">
                        // Final flush on shutdown
                        _ = e.Flush()
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        _ = e.Flush()</span>
                }
        }
}

// Close closes the exporter and flushes remaining data
func (e *ELKExporter) Close() error <span class="cov0" title="0">{
        e.cancel()
        e.wg.Wait()

        // Final flush
        if err := e.Flush(); err != nil </span><span class="cov0" title="0">{
                log.Printf("[ELK] Error during final flush: %v", err)
        }</span>

        <span class="cov0" title="0">if e.client != nil </span><span class="cov0" title="0">{
                return e.client.Close()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ElasticsearchHTTPClient implements ElasticsearchClient using HTTP
type ElasticsearchHTTPClient struct {
        addresses  []string
        username   string
        password   string
        httpClient *http.Client
}

// NewElasticsearchClient creates a new Elasticsearch HTTP client
func NewElasticsearchClient(cfg config.ELKConfiguration) (ElasticsearchClient, error) <span class="cov0" title="0">{
        // For now, use simple HTTP client
        // In production, consider using official Elasticsearch Go client
        return NewElasticsearchHTTPClient(cfg)
}</span>

// NewElasticsearchHTTPClient creates HTTP-based Elasticsearch client
func NewElasticsearchHTTPClient(cfg config.ELKConfiguration) (*ElasticsearchHTTPClient, error) <span class="cov0" title="0">{
        client := &amp;ElasticsearchHTTPClient{
                addresses: cfg.Addresses,
                username:  cfg.Username,
                password:  cfg.Password,
        }

        // Configure HTTP client
        transport := &amp;http.Transport{
                TLSClientConfig: &amp;tls.Config{
                        InsecureSkipVerify: cfg.SkipVerify,
                },
        }

        if cfg.UseTLS </span>{<span class="cov0" title="0">
                // Enable TLS
        }</span>

        <span class="cov0" title="0">client.httpClient = &amp;http.Client{
                Transport: transport,
                Timeout:   10 * time.Second,
        }

        return client, nil</span>
}

// BulkIndex sends bulk index requests to Elasticsearch
func (c *ElasticsearchHTTPClient) BulkIndex(index string, documents []map[string]interface{}) error <span class="cov0" title="0">{
        if len(documents) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Build bulk request body
        <span class="cov0" title="0">var buf bytes.Buffer
        for _, doc := range documents </span><span class="cov0" title="0">{
                // Action line
                action := map[string]interface{}{
                        "index": map[string]interface{}{
                                "_index": index,
                        },
                }
                actionJSON, _ := json.Marshal(action)
                buf.Write(actionJSON)
                buf.WriteString("\n")

                // Document line
                docJSON, _ := json.Marshal(doc)
                buf.Write(docJSON)
                buf.WriteString("\n")
        }</span>

        // Try each address until one succeeds
        <span class="cov0" title="0">var lastErr error
        for _, addr := range c.addresses </span><span class="cov0" title="0">{
                url := fmt.Sprintf("%s/_bulk", addr)
                req, err := http.NewRequest("POST", url, &amp;buf)
                if err != nil </span><span class="cov0" title="0">{
                        lastErr = err
                        continue</span>
                }

                <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
                if c.username != "" &amp;&amp; c.password != "" </span><span class="cov0" title="0">{
                        req.SetBasicAuth(c.username, c.password)
                }</span>

                <span class="cov0" title="0">resp, err := c.httpClient.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        lastErr = err
                        continue</span>
                }
                <span class="cov0" title="0">defer resp.Body.Close()

                if resp.StatusCode &gt;= 200 &amp;&amp; resp.StatusCode &lt; 300 </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Read error response
                <span class="cov0" title="0">var errResp map[string]interface{}
                _ = json.NewDecoder(resp.Body).Decode(&amp;errResp)
                lastErr = fmt.Errorf("Elasticsearch error: %v (status: %d)", errResp, resp.StatusCode)</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("failed to send to all Elasticsearch addresses: %w", lastErr)</span>
}

// Close closes the HTTP client
func (c *ElasticsearchHTTPClient) Close() error <span class="cov0" title="0">{
        // HTTP client doesn't need explicit close
        return nil
}</span>

</pre>
		
		<pre class="file" id="file18" style="display: none">package honeypot

import (
        "fmt"
        "strings"
)

// VirtualFileSystem represents a fake file system for honeypot
type VirtualFileSystem struct {
        files map[string]string
        dirs  map[string][]string
}

// NewVirtualFileSystem creates a new virtual file system
func NewVirtualFileSystem() *VirtualFileSystem <span class="cov0" title="0">{
        vfs := &amp;VirtualFileSystem{
                files: make(map[string]string),
                dirs:  make(map[string][]string),
        }
        vfs.init()
        return vfs
}</span>

func (vfs *VirtualFileSystem) init() <span class="cov0" title="0">{
        // Root directory structure
        vfs.dirs["/"] = []string{"root", "home", "etc", "var", "tmp", "usr", "opt", "boot"}
        vfs.dirs["/root"] = []string{".bashrc", ".bash_history", ".ssh", "backup.tar.gz", "config.txt", "logs"}
        vfs.dirs["/home"] = []string{"user", "admin", "www"}
        vfs.dirs["/etc"] = []string{"passwd", "shadow", "hosts", "nginx", "apache2", "mysql"}
        vfs.dirs["/var"] = []string{"log", "www", "backup", "tmp"}
        vfs.dirs["/var/log"] = []string{"auth.log", "syslog", "nginx", "apache2"}
        vfs.dirs["/var/www"] = []string{"html", "uploads", "config.php"}
        vfs.dirs["/tmp"] = []string{"session.tmp", "cache.tmp"}

        // File contents
        vfs.files["/etc/passwd"] = `root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin
proxy:x:13:13:proxy:/bin:/usr/sbin/nologin
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
backup:x:34:34:backup:/var/backups:/usr/sbin/nologin
list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin
irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin
gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin
nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin
systemd-network:x:100:102:systemd Network Management,,,:/run/systemd:/usr/sbin/nologin
systemd-resolve:x:101:103:systemd Resolver,,,:/run/systemd:/usr/sbin/nologin
systemd-timesync:x:102:104:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologin
messagebus:x:103:106::/nonexistent:/usr/sbin/nologin
syslog:x:104:110::/home/syslog:/usr/sbin/nologin
_apt:x:105:65534::/nonexistent:/usr/sbin/nologin
tss:x:106:111:TPM software stack,,,:/var/lib/tpm:/bin/false
uuidd:x:107:112::/run/uuidd:/usr/sbin/nologin
tcpdump:x:108:113::/nonexistent:/usr/sbin/nologin
tcpdump:x:109:114::/nonexistent:/usr/sbin/nologin
sshd:x:110:65534::/run/sshd:/usr/sbin/nologin
landscape:x:111:115::/var/lib/landscape:/usr/sbin/nologin
pollinate:x:112:1::/var/cache/pollinate:/bin/false
ubuntu:x:1000:1000:Ubuntu:/home/ubuntu:/bin/bash
lxd:x:999:100::/var/snap/lxd/common/lxd:/bin/false
`

        vfs.files["/etc/hosts"] = `127.0.0.1        localhost
127.0.1.1        server
::1                localhost ip6-localhost ip6-loopback
ff02::1                ip6-allnodes
ff02::2                ip6-allrouters
`

        vfs.files["/var/log/auth.log"] = `Dec 15 10:23:15 server sshd[1234]: Accepted publickey for root from 192.168.1.100 port 54321 ssh2
Dec 15 10:25:30 server sshd[1235]: Failed password for invalid user admin from 192.168.1.101 port 54322 ssh2
Dec 15 10:26:45 server sshd[1236]: Accepted publickey for ubuntu from 192.168.1.102 port 54323 ssh2
Dec 15 10:28:12 server sudo:     root : TTY=pts/0 ; PWD=/root ; USER=root ; COMMAND=/usr/bin/apt update
Dec 15 10:30:22 server sshd[1237]: Invalid user test from 192.168.1.103 port 54324 ssh2
`

        vfs.files["/var/log/syslog"] = `Dec 15 10:20:01 server systemd[1]: Started Daily apt upgrade and clean activities.
Dec 15 10:20:15 server systemd[1]: Starting Cleanup of Temporary Directories...
Dec 15 10:20:15 server systemd[1]: Started Cleanup of Temporary Directories.
Dec 15 10:23:15 server sshd[1234]: Server listening on 0.0.0.0 port 22.
Dec 15 10:23:15 server sshd[1234]: Server listening on :: port 22.
Dec 15 10:25:30 server kernel: [12345.678901] audit: type=1106 audit(1639561530.123:456): pid=1235 uid=0 auid=4294967295 ses=4294967295 msg='op=PAM:authentication acct="admin" exe="/usr/sbin/sshd" hostname=? addr=192.168.1.101 terminal=ssh res=failed'
`

        vfs.files["/root/.bash_history"] = `cd /var/www
ls -la
cat config.php
mysql -u root -p
exit
`

        vfs.files["/root/config.txt"] = `# Database Configuration
DB_HOST=localhost
DB_USER=admin
DB_PASS=********
DB_NAME=production

# API Keys
API_KEY=sk_live_51H3ll0W0rld
SECRET_KEY=sk_test_4BcDeFgHiJkLmNoPqRsTuVwXyZ
`

        vfs.files["/var/www/config.php"] = `&lt;?php
define('DB_HOST', 'localhost');
define('DB_USER', 'admin');
define('DB_PASS', 'P@ssw0rd123');
define('DB_NAME', 'wordpress');
define('WP_DEBUG', false);
?&gt;`

        vfs.files["/etc/nginx/nginx.conf"] = `user www-data;
worker_processes auto;
pid /run/nginx.pid;

events {
        worker_connections 768;
}

http {
        sendfile on;
        tcp_nopush on;
        tcp_nodelay on;
        keepalive_timeout 65;
        types_hash_max_size 2048;

        include /etc/nginx/mime.types;
        default_type application/octet-stream;

        access_log /var/log/nginx/access.log;
        error_log /var/log/nginx/error.log;

        server {
                listen 80 default_server;
                listen [::]:80 default_server;
                root /var/www/html;
                index index.html index.htm index.nginx-debian.html;
                server_name _;
                location / {
                        try_files $uri $uri/ =404;
                }
        }
}
`
}</span>

// ListFiles returns file listing for a directory
func (vfs *VirtualFileSystem) ListFiles(path string) string <span class="cov0" title="0">{
        path = vfs.normalizePath(path)

        if files, ok := vfs.dirs[path]; ok </span><span class="cov0" title="0">{
                output := fmt.Sprintf("total %d\r\n", len(files))
                for _, file := range files </span><span class="cov0" title="0">{
                        // Simulate file permissions and sizes
                        if strings.HasPrefix(file, ".") </span><span class="cov0" title="0">{
                                output += fmt.Sprintf("-rw-r--r-- 1 root root  1024 Dec 15 10:23 %s\r\n", file)
                        }</span> else<span class="cov0" title="0"> if strings.Contains(file, ".") </span><span class="cov0" title="0">{
                                output += fmt.Sprintf("-rw-r--r-- 1 root root  2048 Dec 15 10:23 %s\r\n", file)
                        }</span> else<span class="cov0" title="0"> {
                                output += fmt.Sprintf("drwxr-xr-x 2 root root  4096 Dec 15 10:23 %s\r\n", file)
                        }</span>
                }
                <span class="cov0" title="0">return output</span>
        }
        <span class="cov0" title="0">return fmt.Sprintf("ls: cannot access '%s': No such file or directory\r\n", path)</span>
}

// ReadFile returns file content
func (vfs *VirtualFileSystem) ReadFile(path string) (string, bool) <span class="cov0" title="0">{
        path = vfs.normalizePath(path)
        content, ok := vfs.files[path]
        return content, ok
}</span>

// FileExists checks if file exists
func (vfs *VirtualFileSystem) FileExists(path string) bool <span class="cov0" title="0">{
        path = vfs.normalizePath(path)
        _, exists := vfs.files[path]
        if !exists </span><span class="cov0" title="0">{
                _, exists = vfs.dirs[path]
        }</span>
        <span class="cov0" title="0">return exists</span>
}

// normalizePath normalizes file path
func (vfs *VirtualFileSystem) normalizePath(path string) string <span class="cov0" title="0">{
        path = strings.TrimSpace(path)
        if path == "" || path == "." </span><span class="cov0" title="0">{
                return "/root"
        }</span>
        <span class="cov0" title="0">if !strings.HasPrefix(path, "/") </span><span class="cov0" title="0">{
                path = "/root/" + path
        }</span>
        <span class="cov0" title="0">return path</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package honeypot

import (
        "net"
)

// Handler handles different service interactions
type Handler struct {
        logChan chan&lt;- string
}

// NewHandler creates a new handler instance
func NewHandler(logChan chan&lt;- string) *Handler <span class="cov0" title="0">{
        return &amp;Handler{
                logChan: logChan,
        }
}</span>

// Handle routes connection to appropriate service handler
func (h *Handler) Handle(conn net.Conn, remote, serviceType, t string) <span class="cov0" title="0">{
        switch serviceType </span>{
        case "ssh":<span class="cov0" title="0">
                h.handleSSH(conn, remote, t)</span>
        case "http":<span class="cov0" title="0">
                h.handleHTTP(conn, remote, t)</span>
        case "telnet":<span class="cov0" title="0">
                h.handleTelnet(conn, remote, t)</span>
        case "mysql":<span class="cov0" title="0">
                h.handleMySQL(conn, remote, t)</span>
        case "redis":<span class="cov0" title="0">
                h.handleRedis(conn, remote, t)</span>
        case "ftp":<span class="cov0" title="0">
                h.handleFTP(conn, remote, t)</span>
        default:<span class="cov0" title="0">
                h.handleSSH(conn, remote, t)</span>
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package honeypot

import (
        "fmt"
        "net"
        "strings"
        "time"

        "phantom-grid/internal/logger"
)

// handleSSH is implemented in ssh_handler.go
// This file now contains other service handlers

// handleHTTP is implemented in http_handler.go

// handleTelnet simulates Telnet login interaction
func (h *Handler) handleTelnet(conn net.Conn, remote, t string) <span class="cov0" title="0">{
        conn.Write([]byte("\r\nUbuntu 20.04.3 LTS\r\n\r\n"))
        time.Sleep(200 * time.Millisecond)
        conn.Write([]byte("server login: "))

        buf := make([]byte, 1024)
        loginAttempts := 0

        n, err := conn.Read(buf)
        if err != nil || n == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">username := strings.TrimSpace(string(buf[:n]))
        h.logChan &lt;- fmt.Sprintf("[%s] TELNET LOGIN ATTEMPT: username='%s'", t, username)

        conn.Write([]byte("\r\nPassword: "))

        n, err = conn.Read(buf)
        if err != nil || n == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">password := strings.TrimSpace(string(buf[:n]))
        loginAttempts++

        ip := strings.Split(remote, ":")[0]
        h.logChan &lt;- fmt.Sprintf("[%s] TELNET PASSWORD ATTEMPT #%d from %s (password length: %d)", t, loginAttempts, ip, len(password))
        logger.LogAttack(ip, fmt.Sprintf("TELNET_LOGIN: user=%s, pass=***", username))

        time.Sleep(500 * time.Millisecond)

        if loginAttempts &lt; 3 </span><span class="cov0" title="0">{
                conn.Write([]byte("\r\nLogin incorrect\r\n\r\n"))
                conn.Write([]byte("server login: "))
                n, err = conn.Read(buf)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">username = strings.TrimSpace(string(buf[:n]))
                conn.Write([]byte("\r\nPassword: "))
                n, err = conn.Read(buf)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">loginAttempts++
                h.logChan &lt;- fmt.Sprintf("[%s] TELNET PASSWORD ATTEMPT #%d from %s", t, loginAttempts, ip)</span>
        }

        <span class="cov0" title="0">conn.Write([]byte("\r\nToo many login attempts. Connection closed.\r\n"))</span>
}

// handleMySQL is implemented in mysql_handler.go

// handleRedis is implemented in redis_handler.go

// handleFTP simulates FTP server interaction
func (h *Handler) handleFTP(conn net.Conn, remote, t string) <span class="cov0" title="0">{
        ip := strings.Split(remote, ":")[0]
        h.logChan &lt;- fmt.Sprintf("[%s] FTP connection from %s", t, ip)
        logger.LogAttack(ip, "FTP_CONNECTION")

        conn.Write([]byte("220 Welcome to FTP Server\r\n"))

        buf := make([]byte, 1024)
        authenticated := false

        for </span><span class="cov0" title="0">{
                n, err := conn.Read(buf)
                if err != nil || n == 0 </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">command := strings.TrimSpace(string(buf[:n]))
                h.logChan &lt;- fmt.Sprintf("[%s] FTP COMMAND: %s", t, command)
                logger.LogAttack(ip, fmt.Sprintf("FTP: %s", command))

                parts := strings.Fields(command)
                if len(parts) == 0 </span><span class="cov0" title="0">{
                        conn.Write([]byte("500 Syntax error\r\n"))
                        continue</span>
                }

                <span class="cov0" title="0">cmd := strings.ToUpper(parts[0])
                args := parts[1:]

                switch cmd </span>{
                case "USER":<span class="cov0" title="0">
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                username := args[0]
                                h.logChan &lt;- fmt.Sprintf("[%s] FTP USER: %s", t, username)
                                conn.Write([]byte("331 Password required\r\n"))
                        }</span> else<span class="cov0" title="0"> {
                                conn.Write([]byte("501 Syntax error in parameters\r\n"))
                        }</span>
                case "PASS":<span class="cov0" title="0">
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                password := args[0]
                                h.logChan &lt;- fmt.Sprintf("[%s] FTP PASS attempt (password length: %d)", t, len(password))
                                logger.LogAttack(ip, "FTP_LOGIN: pass=***")
                                time.Sleep(200 * time.Millisecond)
                                conn.Write([]byte("530 Login incorrect\r\n"))
                        }</span> else<span class="cov0" title="0"> {
                                conn.Write([]byte("501 Syntax error in parameters\r\n"))
                        }</span>
                case "SYST":<span class="cov0" title="0">
                        conn.Write([]byte("215 UNIX Type: L8\r\n"))</span>
                case "PWD":<span class="cov0" title="0">
                        conn.Write([]byte("257 \"/\" is current directory\r\n"))</span>
                case "LIST", "LS":<span class="cov0" title="0">
                        if authenticated </span><span class="cov0" title="0">{
                                conn.Write([]byte("150 Opening ASCII mode data connection\r\n"))
                                time.Sleep(100 * time.Millisecond)
                                conn.Write([]byte("226 Transfer complete\r\n"))
                        }</span> else<span class="cov0" title="0"> {
                                conn.Write([]byte("530 Please login with USER and PASS\r\n"))
                        }</span>
                case "CWD":<span class="cov0" title="0">
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                conn.Write([]byte(fmt.Sprintf("250 CWD command successful: %s\r\n", args[0])))
                        }</span> else<span class="cov0" title="0"> {
                                conn.Write([]byte("501 Syntax error in parameters\r\n"))
                        }</span>
                case "RETR", "GET":<span class="cov0" title="0">
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                conn.Write([]byte("550 File not found\r\n"))
                        }</span> else<span class="cov0" title="0"> {
                                conn.Write([]byte("501 Syntax error in parameters\r\n"))
                        }</span>
                case "STOR", "PUT":<span class="cov0" title="0">
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                conn.Write([]byte("553 Requested action not taken\r\n"))
                        }</span> else<span class="cov0" title="0"> {
                                conn.Write([]byte("501 Syntax error in parameters\r\n"))
                        }</span>
                case "QUIT", "BYE":<span class="cov0" title="0">
                        conn.Write([]byte("221 Goodbye\r\n"))
                        return</span>
                case "HELP":<span class="cov0" title="0">
                        conn.Write([]byte("214-The following commands are recognized:\r\n"))
                        conn.Write([]byte(" USER PASS SYST PWD LIST CWD RETR STOR QUIT\r\n"))
                        conn.Write([]byte("214 Help OK\r\n"))</span>
                default:<span class="cov0" title="0">
                        conn.Write([]byte("502 Command not implemented\r\n"))</span>
                }
        }
}

</pre>
		
		<pre class="file" id="file21" style="display: none">package honeypot

import (
        "fmt"
        "net"
        "strings"
        "sync"
        "time"

        "phantom-grid/internal/config"
        "phantom-grid/internal/logger"
        "phantom-grid/internal/mirage"
)

// Honeypot manages multiple fake port listeners
type Honeypot struct {
        logChan   chan&lt;- string
        listeners []net.Listener
        wg        sync.WaitGroup
}

// New creates a new Honeypot instance
func New(logChan chan&lt;- string) *Honeypot <span class="cov0" title="0">{
        return &amp;Honeypot{
                logChan:   logChan,
                listeners: make([]net.Listener, 0),
        }
}</span>

// Start binds to fake ports and starts accepting connections
func (h *Honeypot) Start() error <span class="cov0" title="0">{
        var boundPorts []int

        // Try to bind all fake ports
        for _, port := range config.FakePorts </span><span class="cov0" title="0">{
                ln, err := net.Listen("tcp", fmt.Sprintf(":%d", port))
                if err != nil </span><span class="cov0" title="0">{
                        h.logChan &lt;- fmt.Sprintf("[WARN] Cannot bind port %d: %v (XDP will redirect to 9999)", port, err)
                        continue</span>
                }
                <span class="cov0" title="0">h.listeners = append(h.listeners, ln)
                boundPorts = append(boundPorts, port)
                h.logChan &lt;- fmt.Sprintf("[SYSTEM] Honeypot listening on port %d", port)

                h.wg.Add(1)
                go h.acceptLoop(ln, port)</span>
        }

        // Bind fallback port
        <span class="cov0" title="0">if err := h.bindFallback(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">h.logChan &lt;- fmt.Sprintf("[SYSTEM] Honeypot bound to %d ports (%d direct, 1 fallback) - The Mirage active", len(h.listeners), len(boundPorts))
        h.logChan &lt;- "[SYSTEM] Honeypot is now ACCEPTING connections on port 9999"
        h.logChan &lt;- "[SYSTEM] Ready to receive traffic from external hosts"

        return nil</span>
}

func (h *Honeypot) bindFallback() error <span class="cov0" title="0">{
        h.logChan &lt;- fmt.Sprintf("[SYSTEM] Attempting to bind honeypot fallback port %d...", config.HoneypotPort)
        ln9999, err := net.Listen("tcp", fmt.Sprintf(":%d", config.HoneypotPort))
        if err != nil </span><span class="cov0" title="0">{
                h.logChan &lt;- fmt.Sprintf("[ERROR] Cannot bind port %d: %v", config.HoneypotPort, err)
                h.logChan &lt;- fmt.Sprintf("[ERROR] Port %d is REQUIRED for XDP redirect fallback!", config.HoneypotPort)
                h.logChan &lt;- fmt.Sprintf("[ERROR] The eBPF program (internal/ebpf/programs/phantom.c) hardcodes redirect to port %d", config.HoneypotPort)
                h.logChan &lt;- fmt.Sprintf("[ERROR] To free port %d, run: sudo lsof -i :%d &amp;&amp; sudo kill -9 &lt;PID&gt;", config.HoneypotPort, config.HoneypotPort)
                h.logChan &lt;- fmt.Sprintf("[ERROR] Or change HONEYPOT_PORT in internal/ebpf/programs/phantom.c and rebuild")
                h.logChan &lt;- "[ERROR] FAILING FAST: Cannot use alternative ports due to eBPF hardcoded redirect"
                return fmt.Errorf("failed to bind honeypot fallback port %d (required for XDP redirect): %w", config.HoneypotPort, err)
        }</span>

        <span class="cov0" title="0">h.listeners = append(h.listeners, ln9999)
        h.logChan &lt;- fmt.Sprintf("[SYSTEM] Honeypot listening on port %d (fallback for redirected ports)", config.HoneypotPort)
        h.wg.Add(1)
        go h.acceptLoop(ln9999, config.HoneypotPort)
        return nil</span>
}

func (h *Honeypot) acceptLoop(ln net.Listener, port int) <span class="cov0" title="0">{
        defer h.wg.Done()
        for </span><span class="cov0" title="0">{
                conn, err := ln.Accept()
                if err != nil </span><span class="cov0" title="0">{
                        h.logChan &lt;- fmt.Sprintf("[ERROR] Honeypot accept error on port %d: %v", port, err)
                        continue</span>
                }
                <span class="cov0" title="0">remoteAddr := conn.RemoteAddr()
                if remoteAddr != nil </span><span class="cov0" title="0">{
                        h.logChan &lt;- fmt.Sprintf("[DEBUG] Honeypot accepted connection on port %d from %s", port, remoteAddr.String())
                }</span>
                <span class="cov0" title="0">go h.handleConnection(conn, port)</span>
        }
}

func (h *Honeypot) handleConnection(conn net.Conn, originalPort int) <span class="cov0" title="0">{
        defer conn.Close()
        remoteAddr := conn.RemoteAddr()
        if remoteAddr == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">remote := remoteAddr.String()
        ip := extractIP(remote)
        t := time.Now().Format("15:04:05")

        var serviceType string
        if originalPort == config.HoneypotPort </span><span class="cov0" title="0">{
                serviceType = mirage.SelectRandomService()
        }</span> else<span class="cov0" title="0"> {
                serviceType = mirage.SelectServiceByPort(originalPort)
        }</span>
        <span class="cov0" title="0">banner := mirage.GetRandomBanner(serviceType)

        h.logChan &lt;- fmt.Sprintf("[%s] TRAP HIT! IP: %s | Port: %d | Service: %s", t, ip, originalPort, strings.ToUpper(serviceType))
        logger.LogAttack(ip, fmt.Sprintf("TRAP_HIT_PORT_%d", originalPort))

        if _, err := conn.Write([]byte(banner)); err != nil </span><span class="cov0" title="0">{
                h.logChan &lt;- fmt.Sprintf("[%s] Error sending banner to %s: %v", t, ip, err)
                return
        }</span>

        <span class="cov0" title="0">handler := NewHandler(h.logChan)
        handler.Handle(conn, remote, serviceType, t)</span>
}

func extractIP(remote string) string <span class="cov0" title="0">{
        if strings.HasPrefix(remote, "[") </span><span class="cov0" title="0">{
                endBracket := strings.Index(remote, "]")
                if endBracket &gt; 0 </span><span class="cov0" title="0">{
                        return remote[1:endBracket]
                }</span>
                <span class="cov0" title="0">return strings.Split(remote, ":")[0]</span>
        }
        <span class="cov0" title="0">return strings.Split(remote, ":")[0]</span>
}

// Close stops all listeners
func (h *Honeypot) Close() error <span class="cov0" title="0">{
        for _, ln := range h.listeners </span><span class="cov0" title="0">{
                if err := ln.Close(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">h.wg.Wait()
        return nil</span>
}

</pre>
		
		<pre class="file" id="file22" style="display: none">package honeypot

import (
        "fmt"
        "net"
        "strings"
        "time"

        "phantom-grid/internal/logger"
)

// handleHTTP simulates professional HTTP server interaction
func (h *Handler) handleHTTP(conn net.Conn, remote, t string) <span class="cov0" title="0">{
        buf := make([]byte, 8192)
        n, err := conn.Read(buf)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">request := string(buf[:n])
        ip := strings.Split(remote, ":")[0]

        lines := strings.Split(request, "\r\n")
        if len(lines) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">requestLine := lines[0]
        h.logChan &lt;- fmt.Sprintf("[%s] HTTP REQUEST: %s", t, requestLine)
        logger.LogAttack(ip, fmt.Sprintf("HTTP: %s", requestLine))

        parts := strings.Fields(requestLine)
        if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">method := parts[0]
        path := parts[1]
        path = strings.Split(path, "?")[0] // Remove query string

        // Extract User-Agent
        userAgent := "Unknown"
        for _, line := range lines </span><span class="cov0" title="0">{
                if strings.HasPrefix(strings.ToLower(line), "user-agent:") </span><span class="cov0" title="0">{
                        userAgent = strings.TrimSpace(strings.TrimPrefix(line, "User-Agent:"))
                        break</span>
                }
        }

        // Extract credentials from POST
        <span class="cov0" title="0">if method == "POST" </span><span class="cov0" title="0">{
                bodyStart := strings.Index(request, "\r\n\r\n")
                if bodyStart &gt; 0 </span><span class="cov0" title="0">{
                        body := request[bodyStart+4:]
                        if strings.Contains(body, "password") || strings.Contains(body, "pass") </span><span class="cov0" title="0">{
                                h.logChan &lt;- fmt.Sprintf("[%s] HTTP POST with credentials detected! User-Agent: %s", t, userAgent)
                                logger.LogAttack(ip, fmt.Sprintf("HTTP_POST_CREDENTIALS: %s", body))
                        }</span>
                }
        }

        <span class="cov0" title="0">var response string
        time.Sleep(time.Duration(50+len(path)*2) * time.Millisecond) // Realistic delay

        switch path </span>{
        case "/", "/index.html", "/index.php":<span class="cov0" title="0">
                response = "HTTP/1.1 200 OK\r\n"
                response += "Server: nginx/1.18.0 (Ubuntu)\r\n"
                response += "Content-Type: text/html; charset=UTF-8\r\n"
                response += "Connection: keep-alive\r\n"
                response += "X-Powered-By: PHP/7.4.3\r\n"
                response += "\r\n"
                response += `&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Welcome - Server Management&lt;/title&gt;
    &lt;style&gt;
        body { font-family: Arial, sans-serif; margin: 40px; background: #f5f5f5; }
        .container { background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h1 { color: #333; }
        .nav { margin: 20px 0; }
        .nav a { margin-right: 15px; color: #0066cc; text-decoration: none; }
        .nav a:hover { text-decoration: underline; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;h1&gt;Welcome to Server Management Portal&lt;/h1&gt;
        &lt;p&gt;System is running normally. All services are operational.&lt;/p&gt;
        &lt;div class="nav"&gt;
            &lt;a href="/admin"&gt;Admin Panel&lt;/a&gt;
            &lt;a href="/login"&gt;Login&lt;/a&gt;
            &lt;a href="/dashboard"&gt;Dashboard&lt;/a&gt;
            &lt;a href="/api"&gt;API&lt;/a&gt;
        &lt;/div&gt;
        &lt;p&gt;Server Time: ` + time.Now().Format("2006-01-02 15:04:05") + `&lt;/p&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;`</span>

        case "/admin", "/admin.php", "/admin.html", "/administrator", "/wp-admin":<span class="cov0" title="0">
                response = "HTTP/1.1 200 OK\r\n"
                response += "Server: nginx/1.18.0 (Ubuntu)\r\n"
                response += "Content-Type: text/html; charset=UTF-8\r\n"
                response += "Set-Cookie: session_id=abc123xyz; Path=/; HttpOnly\r\n"
                response += "\r\n"
                response += `&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Administration Panel&lt;/title&gt;
    &lt;style&gt;
        body { font-family: Arial, sans-serif; margin: 40px; background: #2c3e50; color: white; }
        .login-box { background: #34495e; padding: 30px; border-radius: 8px; max-width: 400px; margin: 100px auto; }
        input { width: 100%; padding: 10px; margin: 10px 0; border: none; border-radius: 4px; }
        button { width: 100%; padding: 12px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; }
        button:hover { background: #2980b9; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="login-box"&gt;
        &lt;h2&gt;Administration Panel&lt;/h2&gt;
        &lt;form method="POST" action="/admin/login"&gt;
            &lt;input type="text" name="username" placeholder="Username" required&gt;
            &lt;input type="password" name="password" placeholder="Password" required&gt;
            &lt;button type="submit"&gt;Login&lt;/button&gt;
        &lt;/form&gt;
        &lt;p style="font-size: 12px; color: #95a5a6;"&gt;Forgot password? &lt;a href="/admin/reset" style="color: #3498db;"&gt;Reset here&lt;/a&gt;&lt;/p&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;`</span>

        case "/login", "/login.php", "/signin":<span class="cov0" title="0">
                response = "HTTP/1.1 200 OK\r\n"
                response += "Server: Apache/2.4.41 (Debian)\r\n"
                response += "Content-Type: text/html; charset=UTF-8\r\n"
                response += "\r\n"
                response += `&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;User Login&lt;/title&gt;
    &lt;style&gt;
        body { font-family: Arial, sans-serif; margin: 40px; background: #ecf0f1; }
        .form-container { background: white; padding: 30px; border-radius: 8px; max-width: 350px; margin: 50px auto; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        input { width: 100%; padding: 10px; margin: 10px 0; border: 1px solid #ddd; border-radius: 4px; box-sizing: border-box; }
        button { width: 100%; padding: 12px; background: #27ae60; color: white; border: none; border-radius: 4px; cursor: pointer; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="form-container"&gt;
        &lt;h2&gt;User Login&lt;/h2&gt;
        &lt;form method="POST" action="/login/check"&gt;
            &lt;input type="text" name="user" placeholder="Username" required&gt;
            &lt;input type="password" name="pass" placeholder="Password" required&gt;
            &lt;button type="submit"&gt;Sign In&lt;/button&gt;
        &lt;/form&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;`</span>

        case "/api", "/api/v1", "/api/v1/users", "/api/users":<span class="cov0" title="0">
                response = "HTTP/1.1 200 OK\r\n"
                response += "Content-Type: application/json\r\n"
                response += "Access-Control-Allow-Origin: *\r\n"
                response += "\r\n"
                response += `{"status":"ok","data":[{"id":1,"username":"admin","email":"admin@server.com","role":"administrator"},{"id":2,"username":"user","email":"user@server.com","role":"user"}],"timestamp":"` + time.Now().Format(time.RFC3339) + `"}`</span>

        case "/api/v1/config", "/api/config":<span class="cov0" title="0">
                response = "HTTP/1.1 200 OK\r\n"
                response += "Content-Type: application/json\r\n"
                response += "\r\n"
                response += `{"database":{"host":"localhost","port":3306,"name":"production"},"api_key":"sk_live_51H3ll0W0rld","version":"1.2.3"}`</span>

        case "/robots.txt":<span class="cov0" title="0">
                response = "HTTP/1.1 200 OK\r\n"
                response += "Content-Type: text/plain\r\n"
                response += "\r\n"
                response += "User-agent: *\nDisallow: /admin/\nDisallow: /private/\nDisallow: /config/\nAllow: /public/"</span>

        case "/.git/config", "/.git/HEAD", "/.git":<span class="cov0" title="0">
                response = "HTTP/1.1 403 Forbidden\r\n"
                response += "Server: nginx/1.18.0 (Ubuntu)\r\n"
                response += "Content-Type: text/html\r\n"
                response += "\r\n"
                response += "&lt;h1&gt;403 Forbidden&lt;/h1&gt;&lt;p&gt;You don't have permission to access this resource.&lt;/p&gt;"</span>

        case "/phpinfo.php", "/info.php":<span class="cov0" title="0">
                response = "HTTP/1.1 200 OK\r\n"
                response += "Server: Apache/2.4.41 (Debian)\r\n"
                response += "Content-Type: text/html\r\n"
                response += "\r\n"
                response += `&lt;html&gt;&lt;head&gt;&lt;title&gt;phpinfo()&lt;/title&gt;&lt;/head&gt;&lt;body&gt;
&lt;h1&gt;PHP Version 7.4.3&lt;/h1&gt;
&lt;p&gt;System: Linux server 5.4.0-74-generic&lt;/p&gt;
&lt;p&gt;Server API: Apache 2.0 Handler&lt;/p&gt;
&lt;p&gt;Document Root: /var/www/html&lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;`</span>

        case "/wp-login.php", "/wordpress/wp-admin":<span class="cov0" title="0">
                response = "HTTP/1.1 200 OK\r\n"
                response += "Server: nginx/1.18.0 (Ubuntu)\r\n"
                response += "Content-Type: text/html; charset=UTF-8\r\n"
                response += "\r\n"
                response += `&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;WordPress Login&lt;/title&gt;
    &lt;style&gt;
        body { font-family: Arial, sans-serif; margin: 40px; background: #f0f0f1; }
        .login { background: white; padding: 30px; border-radius: 4px; max-width: 320px; margin: 50px auto; }
        input { width: 100%; padding: 10px; margin: 10px 0; border: 1px solid #ddd; }
        button { width: 100%; padding: 12px; background: #0073aa; color: white; border: none; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="login"&gt;
        &lt;h1&gt;WordPress&lt;/h1&gt;
        &lt;form method="POST"&gt;
            &lt;input type="text" name="log" placeholder="Username or Email"&gt;
            &lt;input type="password" name="pwd" placeholder="Password"&gt;
            &lt;button type="submit"&gt;Log In&lt;/button&gt;
        &lt;/form&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;`</span>

        case "/dashboard", "/panel":<span class="cov0" title="0">
                response = "HTTP/1.1 302 Found\r\n"
                response += "Location: /login\r\n"
                response += "\r\n"</span>

        default:<span class="cov0" title="0">
                if method == "POST" </span><span class="cov0" title="0">{
                        h.logChan &lt;- fmt.Sprintf("[%s] HTTP POST to %s - credentials may be present", t, path)
                        response = "HTTP/1.1 302 Found\r\n"
                        response += "Location: /admin/dashboard\r\n"
                        response += "Set-Cookie: auth_token=invalid; Path=/\r\n"
                        response += "\r\n"
                }</span> else<span class="cov0" title="0"> if strings.Contains(path, ".php") || strings.Contains(path, ".jsp") || strings.Contains(path, ".asp") </span><span class="cov0" title="0">{
                        response = "HTTP/1.1 200 OK\r\n"
                        response += "Server: Apache/2.4.41 (Debian)\r\n"
                        response += "Content-Type: text/html\r\n"
                        response += "\r\n"
                        response += "&lt;html&gt;&lt;body&gt;&lt;h1&gt;Page Not Found&lt;/h1&gt;&lt;p&gt;The requested page could not be found.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"
                }</span> else<span class="cov0" title="0"> {
                        response = "HTTP/1.1 404 Not Found\r\n"
                        response += "Server: nginx/1.18.0 (Ubuntu)\r\n"
                        response += "Content-Type: text/html; charset=UTF-8\r\n"
                        response += "\r\n"
                        response += `&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;404 Not Found&lt;/title&gt;
    &lt;style&gt;
        body { font-family: Arial, sans-serif; margin: 40px; text-align: center; }
        h1 { color: #e74c3c; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;404 Not Found&lt;/h1&gt;
    &lt;p&gt;The requested URL ` + path + ` was not found on this server.&lt;/p&gt;
    &lt;p&gt;&lt;a href="/"&gt;Return to homepage&lt;/a&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;`
                }</span>
        }

        <span class="cov0" title="0">conn.Write([]byte(response))
        time.Sleep(100 * time.Millisecond)</span>
}

</pre>
		
		<pre class="file" id="file23" style="display: none">package honeypot

import (
        "fmt"
        "net"
        "strings"
        "time"

        "phantom-grid/internal/logger"
)

// handleMySQL simulates professional MySQL server interaction
func (h *Handler) handleMySQL(conn net.Conn, remote, t string) <span class="cov0" title="0">{
        ip := strings.Split(remote, ":")[0]
        h.logChan &lt;- fmt.Sprintf("[%s] MySQL connection attempt from %s", t, ip)
        logger.LogAttack(ip, "MySQL_CONNECTION")

        // Send initial handshake packet
        handshake := []byte{
                0x4a, 0x00, 0x00, 0x00, // Packet length
                0x0a,                   // Protocol version (10)
        }
        handshake = append(handshake, []byte("8.0.27")...)
        handshake = append(handshake, 0x00)
        handshake = append(handshake, []byte{0x01, 0x00, 0x00, 0x00, 0x40, 0x41, 0x51, 0x27, 0x4a, 0x4b, 0x5c, 0x5d}...)
        handshake = append(handshake, []byte("mysql_native_password")...)
        handshake = append(handshake, 0x00)
        conn.Write(handshake)

        buf := make([]byte, 4096)
        authenticated := false
        username := ""

        for </span><span class="cov0" title="0">{
                n, err := conn.Read(buf)
                if err != nil || n == 0 </span><span class="cov0" title="0">{
                        return
                }</span>

                // Parse login packet
                <span class="cov0" title="0">if !authenticated &amp;&amp; n &gt; 4 </span><span class="cov0" title="0">{
                        usernameLen := int(buf[4])
                        if usernameLen &gt; 0 &amp;&amp; usernameLen &lt; 32 &amp;&amp; n &gt; 5+usernameLen </span><span class="cov0" title="0">{
                                username = string(buf[5 : 5+usernameLen])
                                h.logChan &lt;- fmt.Sprintf("[%s] MySQL LOGIN: username='%s'", t, username)
                                logger.LogAttack(ip, fmt.Sprintf("MySQL_LOGIN: user=%s", username))

                                // Extract password if present
                                passwordStart := 5 + usernameLen + 1
                                if n &gt; passwordStart </span><span class="cov0" title="0">{
                                        passwordLen := int(buf[passwordStart])
                                        if passwordLen &gt; 0 &amp;&amp; passwordLen &lt; 255 &amp;&amp; n &gt; passwordStart+1 </span><span class="cov0" title="0">{
                                                password := string(buf[passwordStart+1 : passwordStart+1+passwordLen])
                                                h.logChan &lt;- fmt.Sprintf("[%s] MySQL PASSWORD attempt (length: %d)", t, len(password))
                                                logger.LogAttack(ip, fmt.Sprintf("MySQL_PASSWORD: length=%d", len(password)))
                                        }</span>
                                }

                                // Send error packet
                                <span class="cov0" title="0">errorPacket := []byte{0xff, 0x15, 0x04, 0x23, 0x28, 0x30, 0x30, 0x30, 0x30, 0x34}
                                errorPacket = append(errorPacket, []byte("Access denied for user '"+username+"'@'"+ip+"' (using password: YES)")...)
                                errorPacket = append(errorPacket, 0x00)
                                conn.Write(errorPacket)
                                time.Sleep(200 * time.Millisecond)

                                // Try to continue as if authenticated for command simulation
                                authenticated = true
                                conn.Write([]byte{0x07, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00}) // OK packet
                                continue</span>
                        }
                }

                // Parse commands after authentication
                <span class="cov0" title="0">if authenticated &amp;&amp; n &gt; 4 </span><span class="cov0" title="0">{
                        command := buf[4]
                        commandStr := string(buf[5:n])

                        h.logChan &lt;- fmt.Sprintf("[%s] MySQL COMMAND: %s", t, commandStr)
                        logger.LogAttack(ip, fmt.Sprintf("MySQL: %s", commandStr))

                        switch command </span>{
                        case 0x03:<span class="cov0" title="0"> // COM_QUERY
                                query := strings.ToUpper(strings.TrimSpace(commandStr))
                                response := h.handleMySQLQuery(query, ip, t)
                                conn.Write(response)</span>
                        case 0x01:<span class="cov0" title="0"> // COM_QUIT
                                conn.Write([]byte{0x07, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00})
                                return</span>
                        default:<span class="cov0" title="0">
                                // Unknown command
                                errorPacket := []byte{0xff, 0x15, 0x04, 0x23, 0x28, 0x30, 0x30, 0x30, 0x30, 0x34}
                                errorPacket = append(errorPacket, []byte("Unknown command")...)
                                errorPacket = append(errorPacket, 0x00)
                                conn.Write(errorPacket)</span>
                        }
                }

                <span class="cov0" title="0">time.Sleep(100 * time.Millisecond)</span>
        }
}

func (h *Handler) handleMySQLQuery(query string, ip, t string) []byte <span class="cov0" title="0">{
        query = strings.ToUpper(strings.TrimSpace(query))

        // SHOW DATABASES
        if strings.HasPrefix(query, "SHOW DATABASES") </span><span class="cov0" title="0">{
                databases := []string{"information_schema", "mysql", "performance_schema", "sys", "wordpress", "production", "test"}
                response := []byte{0x01, 0x00, 0x00, 0x01, 0x01} // Column count: 1
                response = append(response, []byte{0x27, 0x00, 0x00, 0x02, 0x03, 0x64, 0x65, 0x66}...) // Column definition
                response = append(response, []byte("Database")...)
                response = append(response, 0x00)
                for _, db := range databases </span><span class="cov0" title="0">{
                        response = append(response, []byte(fmt.Sprintf("%c%s", len(db), db))...)
                }</span>
                <span class="cov0" title="0">return response</span>
        }

        // USE database
        <span class="cov0" title="0">if strings.HasPrefix(query, "USE ") </span><span class="cov0" title="0">{
                dbName := strings.TrimSpace(strings.TrimPrefix(query, "USE"))
                h.logChan &lt;- fmt.Sprintf("[%s] MySQL USE DATABASE: %s", t, dbName)
                return []byte{0x07, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00} // OK packet
        }</span>

        // SELECT queries
        <span class="cov0" title="0">if strings.HasPrefix(query, "SELECT") </span><span class="cov0" title="0">{
                if strings.Contains(query, "FROM USERS") || strings.Contains(query, "FROM USER") </span><span class="cov0" title="0">{
                        // Simulate user table
                        response := []byte{0x01, 0x00, 0x00, 0x01, 0x03} // 3 columns
                        response = append(response, []byte("id")...)
                        response = append(response, 0x00)
                        response = append(response, []byte("username")...)
                        response = append(response, 0x00)
                        response = append(response, []byte("password")...)
                        response = append(response, 0x00)
                        // Add some fake rows
                        response = append(response, []byte{0x01, 0x00, 0x00, 0x02, 0x31, 0x61, 0x64, 0x6d, 0x69, 0x6e, 0x2a, 0x2a, 0x2a}...)
                        return response
                }</span>
                <span class="cov0" title="0">if strings.Contains(query, "VERSION()") </span><span class="cov0" title="0">{
                        return []byte{0x01, 0x00, 0x00, 0x01, 0x01, 0x07, 0x00, 0x00, 0x02, 0x38, 0x2e, 0x30, 0x2e, 0x32, 0x37} // "8.0.27"
                }</span>
                // Generic SELECT response
                <span class="cov0" title="0">return []byte{0x01, 0x00, 0x00, 0x01, 0x00}</span> // Empty result
        }

        // SHOW TABLES
        <span class="cov0" title="0">if strings.HasPrefix(query, "SHOW TABLES") </span><span class="cov0" title="0">{
                tables := []string{"users", "posts", "comments", "settings", "logs"}
                response := []byte{0x01, 0x00, 0x00, 0x01, 0x01} // Column count
                response = append(response, []byte("Tables_in_database")...)
                response = append(response, 0x00)
                for _, table := range tables </span><span class="cov0" title="0">{
                        response = append(response, []byte(fmt.Sprintf("%c%s", len(table), table))...)
                }</span>
                <span class="cov0" title="0">return response</span>
        }

        // SHOW CREATE TABLE
        <span class="cov0" title="0">if strings.HasPrefix(query, "SHOW CREATE TABLE") </span><span class="cov0" title="0">{
                tableName := strings.TrimSpace(strings.TrimPrefix(query, "SHOW CREATE TABLE"))
                h.logChan &lt;- fmt.Sprintf("[%s] MySQL SHOW CREATE TABLE: %s", t, tableName)
                response := []byte{0x01, 0x00, 0x00, 0x01, 0x02} // 2 columns
                response = append(response, []byte("Table")...)
                response = append(response, 0x00)
                response = append(response, []byte("Create Table")...)
                response = append(response, 0x00)
                createSQL := fmt.Sprintf("CREATE TABLE `%s` (`id` int(11) NOT NULL AUTO_INCREMENT, PRIMARY KEY (`id`))", tableName)
                response = append(response, []byte(fmt.Sprintf("%c%s", len(createSQL), createSQL))...)
                return response
        }</span>

        // INSERT, UPDATE, DELETE
        <span class="cov0" title="0">if strings.HasPrefix(query, "INSERT") || strings.HasPrefix(query, "UPDATE") || strings.HasPrefix(query, "DELETE") </span><span class="cov0" title="0">{
                h.logChan &lt;- fmt.Sprintf("[%s] MySQL MODIFY QUERY: %s", t, query)
                logger.LogAttack(ip, fmt.Sprintf("MySQL_MODIFY: %s", query))
                return []byte{0x07, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00} // OK - 1 row affected
        }</span>

        // Default error response
        <span class="cov0" title="0">errorPacket := []byte{0xff, 0x15, 0x04, 0x23, 0x28, 0x30, 0x30, 0x30, 0x30, 0x34}
        errorPacket = append(errorPacket, []byte("You have an error in your SQL syntax")...)
        errorPacket = append(errorPacket, 0x00)
        return errorPacket</span>
}

</pre>
		
		<pre class="file" id="file24" style="display: none">package honeypot

import (
        "fmt"
        "net"
        "strings"
        "time"

        "phantom-grid/internal/logger"
)

// handleRedis simulates professional Redis server interaction
func (h *Handler) handleRedis(conn net.Conn, remote, t string) <span class="cov0" title="0">{
        ip := strings.Split(remote, ":")[0]
        h.logChan &lt;- fmt.Sprintf("[%s] Redis connection from %s", t, ip)
        logger.LogAttack(ip, "REDIS_CONNECTION")

        buf := make([]byte, 4096)

        for </span><span class="cov0" title="0">{
                n, err := conn.Read(buf)
                if err != nil || n == 0 </span><span class="cov0" title="0">{
                        return
                }</span>

                // Parse Redis protocol (RESP)
                <span class="cov0" title="0">command := strings.TrimSpace(string(buf[:n]))
                h.logChan &lt;- fmt.Sprintf("[%s] REDIS COMMAND: %s", t, command)
                logger.LogAttack(ip, fmt.Sprintf("REDIS: %s", command))

                // Parse RESP format
                parts := h.parseRESP(command)
                if len(parts) == 0 </span><span class="cov0" title="0">{
                        conn.Write([]byte("-ERR unknown command\r\n"))
                        continue</span>
                }

                <span class="cov0" title="0">cmd := strings.ToUpper(parts[0])
                args := parts[1:]

                time.Sleep(50 * time.Millisecond) // Realistic delay

                switch cmd </span>{
                case "PING":<span class="cov0" title="0">
                        conn.Write([]byte("+PONG\r\n"))</span>

                case "INFO":<span class="cov0" title="0">
                        info := "# Server\r\n"
                        info += "redis_version:6.2.6\r\n"
                        info += "redis_mode:standalone\r\n"
                        info += "os:Linux 5.4.0 x86_64\r\n"
                        info += "arch_bits:64\r\n"
                        info += "multiplexing_api:epoll\r\n"
                        info += "process_id:1234\r\n"
                        info += "run_id:abc123def456\r\n"
                        info += "tcp_port:6379\r\n"
                        info += "uptime_in_seconds:86400\r\n"
                        info += "uptime_in_days:1\r\n"
                        info += "connected_clients:1\r\n"
                        info += "used_memory:1048576\r\n"
                        info += "used_memory_human:1.00M\r\n"
                        conn.Write([]byte(fmt.Sprintf("$%d\r\n%s\r\n", len(info), info)))</span>

                case "GET":<span class="cov0" title="0">
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                key := args[0]
                                h.logChan &lt;- fmt.Sprintf("[%s] REDIS GET: key='%s'", t, key)
                                // Return nil (key not found)
                                conn.Write([]byte("$-1\r\n"))
                        }</span> else<span class="cov0" title="0"> {
                                conn.Write([]byte("-ERR wrong number of arguments for 'get' command\r\n"))
                        }</span>

                case "SET":<span class="cov0" title="0">
                        if len(args) &gt;= 2 </span><span class="cov0" title="0">{
                                key := args[0]
                                value := args[1]
                                h.logChan &lt;- fmt.Sprintf("[%s] REDIS SET: key='%s', value_length=%d", t, key, len(value))
                                logger.LogAttack(ip, fmt.Sprintf("REDIS_SET: key=%s, value_len=%d", key, len(value)))
                                _ = value // Logged above
                                conn.Write([]byte("+OK\r\n"))
                        }</span> else<span class="cov0" title="0"> {
                                conn.Write([]byte("-ERR wrong number of arguments for 'set' command\r\n"))
                        }</span>

                case "KEYS":<span class="cov0" title="0">
                        pattern := "*"
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                pattern = args[0]
                        }</span>
                        <span class="cov0" title="0">h.logChan &lt;- fmt.Sprintf("[%s] REDIS KEYS: pattern='%s'", t, pattern)
                        // Return empty list
                        conn.Write([]byte("*0\r\n"))</span>

                case "AUTH":<span class="cov0" title="0">
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                password := args[0]
                                h.logChan &lt;- fmt.Sprintf("[%s] REDIS AUTH attempt (password length: %d)", t, len(password))
                                logger.LogAttack(ip, "REDIS_AUTH: password=***")
                                conn.Write([]byte("-ERR invalid password\r\n"))
                        }</span> else<span class="cov0" title="0"> {
                                conn.Write([]byte("-ERR wrong number of arguments for 'auth' command\r\n"))
                        }</span>

                case "CONFIG":<span class="cov0" title="0">
                        if len(args) &gt; 0 &amp;&amp; strings.ToUpper(args[0]) == "GET" </span><span class="cov0" title="0">{
                                configKey := "*"
                                if len(args) &gt; 1 </span><span class="cov0" title="0">{
                                        configKey = args[1]
                                }</span>
                                <span class="cov0" title="0">h.logChan &lt;- fmt.Sprintf("[%s] REDIS CONFIG GET: %s", t, configKey)
                                logger.LogAttack(ip, fmt.Sprintf("REDIS_CONFIG: %s", configKey))
                                conn.Write([]byte("*2\r\n$7\r\nrequirepass\r\n$0\r\n\r\n"))</span>
                        } else<span class="cov0" title="0"> {
                                conn.Write([]byte("-ERR unknown subcommand or wrong number of arguments\r\n"))
                        }</span>

                case "HGET":<span class="cov0" title="0">
                        if len(args) &gt;= 2 </span><span class="cov0" title="0">{
                                key := args[0]
                                field := args[1]
                                h.logChan &lt;- fmt.Sprintf("[%s] REDIS HGET: key='%s', field='%s'", t, key, field)
                                conn.Write([]byte("$-1\r\n"))
                        }</span> else<span class="cov0" title="0"> {
                                conn.Write([]byte("-ERR wrong number of arguments for 'hget' command\r\n"))
                        }</span>

                case "HSET":<span class="cov0" title="0">
                        if len(args) &gt;= 3 </span><span class="cov0" title="0">{
                                key := args[0]
                                field := args[1]
                                value := args[2]
                                h.logChan &lt;- fmt.Sprintf("[%s] REDIS HSET: key='%s', field='%s', value_length=%d", t, key, field, len(value))
                                logger.LogAttack(ip, fmt.Sprintf("REDIS_HSET: key=%s, field=%s, value_len=%d", key, field, len(value)))
                                _ = value // Logged above
                                conn.Write([]byte(":1\r\n"))
                        }</span> else<span class="cov0" title="0"> {
                                conn.Write([]byte("-ERR wrong number of arguments for 'hset' command\r\n"))
                        }</span>

                case "HGETALL":<span class="cov0" title="0">
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                key := args[0]
                                h.logChan &lt;- fmt.Sprintf("[%s] REDIS HGETALL: key='%s'", t, key)
                                conn.Write([]byte("*0\r\n"))
                        }</span> else<span class="cov0" title="0"> {
                                conn.Write([]byte("-ERR wrong number of arguments for 'hgetall' command\r\n"))
                        }</span>

                case "LPUSH", "RPUSH":<span class="cov0" title="0">
                        if len(args) &gt;= 2 </span><span class="cov0" title="0">{
                                key := args[0]
                                _ = args[1] // value
                                h.logChan &lt;- fmt.Sprintf("[%s] REDIS %s: key='%s'", t, cmd, key)
                                logger.LogAttack(ip, fmt.Sprintf("REDIS_%s: key=%s", cmd, key))
                                conn.Write([]byte(":1\r\n"))
                        }</span> else<span class="cov0" title="0"> {
                                conn.Write([]byte(fmt.Sprintf("-ERR wrong number of arguments for '%s' command\r\n", strings.ToLower(cmd))))
                        }</span>

                case "LRANGE":<span class="cov0" title="0">
                        if len(args) &gt;= 3 </span><span class="cov0" title="0">{
                                key := args[0]
                                start := args[1]
                                stop := args[2]
                                h.logChan &lt;- fmt.Sprintf("[%s] REDIS LRANGE: key='%s', start=%s, stop=%s", t, key, start, stop)
                                conn.Write([]byte("*0\r\n"))
                        }</span> else<span class="cov0" title="0"> {
                                conn.Write([]byte("-ERR wrong number of arguments for 'lrange' command\r\n"))
                        }</span>

                case "FLUSHALL", "FLUSHDB":<span class="cov0" title="0">
                        h.logChan &lt;- fmt.Sprintf("[%s] REDIS %s: DANGEROUS COMMAND!", t, cmd)
                        logger.LogAttack(ip, fmt.Sprintf("REDIS_%s: DANGEROUS", cmd))
                        conn.Write([]byte("+OK\r\n"))</span>

                case "EVAL", "EVALSHA":<span class="cov0" title="0">
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                script := args[0]
                                h.logChan &lt;- fmt.Sprintf("[%s] REDIS %s: script execution attempt (length: %d)", t, cmd, len(script))
                                logger.LogAttack(ip, fmt.Sprintf("REDIS_%s: script_length=%d", cmd, len(script)))
                                conn.Write([]byte("-ERR script execution not allowed\r\n"))
                        }</span> else<span class="cov0" title="0"> {
                                conn.Write([]byte("-ERR wrong number of arguments\r\n"))
                        }</span>

                case "SAVE", "BGSAVE":<span class="cov0" title="0">
                        h.logChan &lt;- fmt.Sprintf("[%s] REDIS %s: backup command", t, cmd)
                        conn.Write([]byte("+OK\r\n"))</span>

                case "DBSIZE":<span class="cov0" title="0">
                        conn.Write([]byte(":0\r\n"))</span>

                case "SELECT":<span class="cov0" title="0">
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                db := args[0]
                                h.logChan &lt;- fmt.Sprintf("[%s] REDIS SELECT: database=%s", t, db)
                                conn.Write([]byte("+OK\r\n"))
                        }</span> else<span class="cov0" title="0"> {
                                conn.Write([]byte("-ERR wrong number of arguments for 'select' command\r\n"))
                        }</span>

                case "QUIT", "EXIT":<span class="cov0" title="0">
                        conn.Write([]byte("+OK\r\n"))
                        return</span>

                default:<span class="cov0" title="0">
                        conn.Write([]byte(fmt.Sprintf("-ERR unknown command '%s'\r\n", strings.ToLower(cmd))))</span>
                }
        }
}

// parseRESP parses Redis RESP protocol format
func (h *Handler) parseRESP(input string) []string <span class="cov0" title="0">{
        parts := []string{}
        lines := strings.Split(input, "\r\n")
        
        for i := 0; i &lt; len(lines); i++ </span><span class="cov0" title="0">{
                line := lines[i]
                if len(line) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov0" title="0">if line[0] == '*' </span><span class="cov0" title="0">{
                        // Array
                        count := 0
                        fmt.Sscanf(line, "*%d", &amp;count)
                        for j := 0; j &lt; count &amp;&amp; i+1 &lt; len(lines); j++ </span><span class="cov0" title="0">{
                                i++
                                if i &lt; len(lines) &amp;&amp; len(lines[i]) &gt; 0 &amp;&amp; lines[i][0] == '$' </span><span class="cov0" title="0">{
                                        // String length
                                        var strLen int
                                        fmt.Sscanf(lines[i], "$%d", &amp;strLen)
                                        i++
                                        if i &lt; len(lines) </span><span class="cov0" title="0">{
                                                parts = append(parts, lines[i])
                                        }</span>
                                }
                        }
                } else<span class="cov0" title="0"> if line[0] == '$' </span><span class="cov0" title="0">{
                        // String
                        var strLen int
                        fmt.Sscanf(line, "$%d", &amp;strLen)
                        i++
                        if i &lt; len(lines) </span><span class="cov0" title="0">{
                                parts = append(parts, lines[i])
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Simple string or error
                        if strings.HasPrefix(line, "+") || strings.HasPrefix(line, "-") </span><span class="cov0" title="0">{
                                parts = append(parts, line[1:])
                        }</span> else<span class="cov0" title="0"> {
                                // Try to parse as space-separated command
                                fields := strings.Fields(line)
                                parts = append(parts, fields...)
                        }</span>
                }
        }
        
        // Fallback: simple space-separated parsing
        <span class="cov0" title="0">if len(parts) == 0 </span><span class="cov0" title="0">{
                parts = strings.Fields(input)
        }</span>
        
        <span class="cov0" title="0">return parts</span>
}

</pre>
		
		<pre class="file" id="file25" style="display: none">package honeypot

import (
        "fmt"
        "math/rand"
        "net"
        "strings"
        "time"

        "phantom-grid/internal/logger"
)

// handleSSH simulates professional SSH shell interaction
func (h *Handler) handleSSH(conn net.Conn, remote, t string) <span class="cov0" title="0">{
        time.Sleep(100 * time.Millisecond)

        ip := strings.Split(remote, ":")[0]
        vfs := NewVirtualFileSystem()
        currentDir := "/root"
        prompt := fmt.Sprintf("root@server:%s# ", currentDir)
        commandHistory := []string{}

        conn.Write([]byte(prompt))

        buf := make([]byte, 4096)
        for </span><span class="cov0" title="0">{
                n, err := conn.Read(buf)
                if err != nil || n == 0 </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">input := strings.TrimSpace(string(buf[:n]))
                if len(input) == 0 </span><span class="cov0" title="0">{
                        conn.Write([]byte(prompt))
                        continue</span>
                }

                // Log command
                <span class="cov0" title="0">h.logChan &lt;- fmt.Sprintf("[%s] SSH COMMAND: %s", t, input)
                logger.LogAttack(ip, fmt.Sprintf("SSH: %s", input))
                commandHistory = append(commandHistory, input)

                parts := strings.Fields(input)
                if len(parts) == 0 </span><span class="cov0" title="0">{
                        conn.Write([]byte(prompt))
                        continue</span>
                }

                <span class="cov0" title="0">cmd := parts[0]
                args := parts[1:]

                // Add small delay for realism
                time.Sleep(time.Duration(50+rand.Intn(100)) * time.Millisecond)

                switch cmd </span>{
                case "exit", "logout", "quit":<span class="cov0" title="0">
                        conn.Write([]byte("Connection closed by foreign host.\r\n"))
                        return</span>

                case "ls", "ls -la", "ls -l", "ls -a":<span class="cov0" title="0">
                        output := vfs.ListFiles(currentDir)
                        conn.Write([]byte(output + prompt))</span>

                case "pwd":<span class="cov0" title="0">
                        conn.Write([]byte(currentDir + "\r\n" + prompt))</span>

                case "whoami":<span class="cov0" title="0">
                        conn.Write([]byte("root\r\n" + prompt))</span>

                case "id":<span class="cov0" title="0">
                        conn.Write([]byte("uid=0(root) gid=0(root) groups=0(root)\r\n" + prompt))</span>

                case "uname":<span class="cov0" title="0">
                        if len(args) &gt; 0 &amp;&amp; args[0] == "-a" </span><span class="cov0" title="0">{
                                conn.Write([]byte("Linux server 5.4.0-74-generic #83-Ubuntu SMP Sat May 8 02:35:04 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux\r\n" + prompt))
                        }</span> else<span class="cov0" title="0"> {
                                conn.Write([]byte("Linux\r\n" + prompt))
                        }</span>

                case "cat", "less", "more":<span class="cov0" title="0">
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                filename := args[0]
                                if !strings.HasPrefix(filename, "/") </span><span class="cov0" title="0">{
                                        filename = currentDir + "/" + filename
                                }</span>
                                <span class="cov0" title="0">if content, ok := vfs.ReadFile(filename); ok </span><span class="cov0" title="0">{
                                        conn.Write([]byte(content + prompt))
                                }</span> else<span class="cov0" title="0"> if filename == "/etc/shadow" </span><span class="cov0" title="0">{
                                        conn.Write([]byte("cat: /etc/shadow: Permission denied\r\n" + prompt))
                                }</span> else<span class="cov0" title="0"> {
                                        conn.Write([]byte(fmt.Sprintf("cat: %s: No such file or directory\r\n", args[0]) + prompt))
                                }</span>
                        } else<span class="cov0" title="0"> {
                                conn.Write([]byte(fmt.Sprintf("%s: missing file operand\r\n", cmd) + prompt))
                        }</span>

                case "cd":<span class="cov0" title="0">
                        if len(args) == 0 </span><span class="cov0" title="0">{
                                currentDir = "/root"
                        }</span> else<span class="cov0" title="0"> {
                                dir := args[0]
                                if dir == ".." </span><span class="cov0" title="0">{
                                        if currentDir != "/" </span><span class="cov0" title="0">{
                                                parts := strings.Split(strings.Trim(currentDir, "/"), "/")
                                                if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                                                        currentDir = "/" + strings.Join(parts[:len(parts)-1], "/")
                                                }</span> else<span class="cov0" title="0"> {
                                                        currentDir = "/"
                                                }</span>
                                        }
                                } else<span class="cov0" title="0"> if dir == "/" </span><span class="cov0" title="0">{
                                        currentDir = "/"
                                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(dir, "/") </span><span class="cov0" title="0">{
                                        if vfs.FileExists(dir) </span><span class="cov0" title="0">{
                                                currentDir = dir
                                        }</span> else<span class="cov0" title="0"> {
                                                conn.Write([]byte(fmt.Sprintf("bash: cd: %s: No such file or directory\r\n", dir) + prompt))
                                                continue</span>
                                        }
                                } else<span class="cov0" title="0"> {
                                        newDir := currentDir + "/" + dir
                                        if vfs.FileExists(newDir) </span><span class="cov0" title="0">{
                                                currentDir = newDir
                                        }</span> else<span class="cov0" title="0"> {
                                                conn.Write([]byte(fmt.Sprintf("bash: cd: %s: No such file or directory\r\n", dir) + prompt))
                                                continue</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">prompt = fmt.Sprintf("root@server:%s# ", currentDir)
                        conn.Write([]byte(prompt))</span>

                case "history":<span class="cov0" title="0">
                        output := ""
                        for i, cmd := range commandHistory </span><span class="cov0" title="0">{
                                if i &lt; len(commandHistory)-1 </span><span class="cov0" title="0">{
                                        output += fmt.Sprintf(" %4d  %s\r\n", i+1, cmd)
                                }</span>
                        }
                        <span class="cov0" title="0">conn.Write([]byte(output + prompt))</span>

                case "ps":<span class="cov0" title="0">
                        output := "  PID TTY          TIME CMD\r\n"
                        output += "    1 ?        00:00:01 systemd\r\n"
                        output += "  456 ?        00:00:02 sshd\r\n"
                        output += "  789 ?        00:00:00 nginx\r\n"
                        output += "  890 ?        00:00:01 mysqld\r\n"
                        output += "  901 ?        00:00:00 redis-server\r\n"
                        output += " 1234 ?        00:00:00 apache2\r\n"
                        if len(args) &gt; 0 &amp;&amp; args[0] == "aux" </span><span class="cov0" title="0">{
                                output = "USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\r\n"
                                output += "root         1  0.0  0.1  22536  3824 ?        Ss   Dec10   0:01 /sbin/init\r\n"
                                output += "root       456  0.0  0.2  47864  8960 ?        Ss   Dec10   0:02 /usr/sbin/sshd\r\n"
                                output += "root       789  0.0  0.1  23456  5120 ?        S    Dec10   0:00 /usr/sbin/nginx\r\n"
                                output += "mysql      890  0.1  2.5 123456 25600 ?        Sl   Dec10   0:15 /usr/sbin/mysqld\r\n"
                                output += "redis      901  0.0  0.3  12345  3072 ?        Ssl  Dec10   0:01 /usr/bin/redis-server\r\n"
                                output += "www-data  1234  0.0  0.2  34567  2048 ?        S    Dec10   0:00 /usr/sbin/apache2\r\n"
                        }</span>
                        <span class="cov0" title="0">conn.Write([]byte(output + prompt))</span>

                case "netstat":<span class="cov0" title="0">
                        output := "Active Internet connections (w/o servers)\r\n"
                        output += "Proto Recv-Q Send-Q Local Address           Foreign Address         State\r\n"
                        output += "tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN\r\n"
                        output += "tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN\r\n"
                        output += "tcp        0      0 0.0.0.0:443             0.0.0.0:*               LISTEN\r\n"
                        output += "tcp        0      0 0.0.0.0:3306            0.0.0.0:*               LISTEN\r\n"
                        if len(args) &gt; 0 &amp;&amp; args[0] == "-an" </span><span class="cov0" title="0">{
                                output = "Active Internet connections (servers and established)\r\n"
                                output += "Proto Recv-Q Send-Q Local Address           Foreign Address         State\r\n"
                                output += "tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN\r\n"
                                output += "tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN\r\n"
                                output += "tcp        0      0 127.0.0.1:3306          0.0.0.0:*               LISTEN\r\n"
                        }</span>
                        <span class="cov0" title="0">conn.Write([]byte(output + prompt))</span>

                case "ifconfig", "ip":<span class="cov0" title="0">
                        if cmd == "ip" &amp;&amp; len(args) &gt; 0 &amp;&amp; args[0] == "addr" </span><span class="cov0" title="0">{
                                output := "1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\r\n"
                                output += "    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\r\n"
                                output += "    inet 127.0.0.1/8 scope host lo\r\n"
                                output += "       valid_lft forever preferred_lft forever\r\n"
                                output += "2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000\r\n"
                                output += "    link/ether 00:0c:29:12:34:56 brd ff:ff:ff:ff:ff:ff\r\n"
                                output += "    inet 192.168.1.100/24 brd 192.168.1.255 scope global eth0\r\n"
                                output += "       valid_lft forever preferred_lft forever\r\n"
                                conn.Write([]byte(output + prompt))
                        }</span> else<span class="cov0" title="0"> {
                                output := "eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500\r\n"
                                output += "        inet 192.168.1.100  netmask 255.255.255.0  broadcast 192.168.1.255\r\n"
                                output += "        ether 00:0c:29:12:34:56  txqueuelen 1000  (Ethernet)\r\n"
                                output += "        RX packets 12345  bytes 1234567 (1.2 MB)\r\n"
                                output += "        RX errors 0  dropped 0  overruns 0  frame 0\r\n"
                                output += "        TX packets 9876  bytes 987654 (987.6 KB)\r\n"
                                output += "        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\r\n"
                                conn.Write([]byte(output + prompt))
                        }</span>

                case "df":<span class="cov0" title="0">
                        output := "Filesystem     1K-blocks    Used Available Use% Mounted on\r\n"
                        output += "/dev/sda1       20971520 8388608  12582912  40% /\r\n"
                        output += "tmpfs             524288       0    524288   0% /dev/shm\r\n"
                        output += "/dev/sda2       52428800 10485760  41943040  20% /home\r\n"
                        conn.Write([]byte(output + prompt))</span>

                case "free":<span class="cov0" title="0">
                        output := "              total        used        free      shared  buff/cache   available\r\n"
                        output += "Mem:         8192000     4096000     2048000      512000     2048000     3584000\r\n"
                        output += "Swap:        2097152           0     2097152\r\n"
                        conn.Write([]byte(output + prompt))</span>

                case "top", "htop":<span class="cov0" title="0">
                        output := "top - 10:30:15 up 5 days,  2:15,  1 user,  load average: 0.45, 0.52, 0.48\r\n"
                        output += "Tasks: 125 total,   1 running, 124 sleeping,   0 stopped,   0 zombie\r\n"
                        output += "%Cpu(s):  2.5 us,  1.2 sy,  0.0 ni, 96.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\r\n"
                        output += "MiB Mem :   8000.0 total,   4000.0 free,   2000.0 used,   2000.0 buff/cache\r\n"
                        output += "MiB Swap:   2048.0 total,   2048.0 free,      0.0 used.   5500.0 avail Mem\r\n"
                        output += "\r\n"
                        output += "  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND\r\n"
                        output += "  890 mysql     20   0  123456  25600   5120 S   1.2   0.3   0:15.23 mysqld\r\n"
                        output += "  456 root      20   0   47864   8960   2048 S   0.3   0.1   0:02.45 sshd\r\n"
                        output += "    1 root      20   0   22536   3824   2048 S   0.0   0.0   0:01.23 systemd\r\n"
                        conn.Write([]byte(output + prompt))</span>

                case "grep":<span class="cov0" title="0">
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                pattern := args[0]
                                file := ""
                                if len(args) &gt; 1 </span><span class="cov0" title="0">{
                                        file = args[1]
                                }</span>
                                <span class="cov0" title="0">if file != "" </span><span class="cov0" title="0">{
                                        if content, ok := vfs.ReadFile(file); ok </span><span class="cov0" title="0">{
                                                if strings.Contains(content, pattern) </span><span class="cov0" title="0">{
                                                        conn.Write([]byte(fmt.Sprintf("%s: %s\r\n", file, pattern) + prompt))
                                                }</span> else<span class="cov0" title="0"> {
                                                        conn.Write([]byte(prompt))
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                conn.Write([]byte(fmt.Sprintf("grep: %s: No such file or directory\r\n", file) + prompt))
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        conn.Write([]byte(fmt.Sprintf("grep: missing file operand\r\n") + prompt))
                                }</span>
                        } else<span class="cov0" title="0"> {
                                conn.Write([]byte("grep: missing pattern\r\n" + prompt))
                        }</span>

                case "find":<span class="cov0" title="0">
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                output := ""
                                if args[0] == "/" || args[0] == "." </span><span class="cov0" title="0">{
                                        output = "/root/.bashrc\r\n/root/.bash_history\r\n/etc/passwd\r\n/etc/hosts\r\n"
                                }</span>
                                <span class="cov0" title="0">conn.Write([]byte(output + prompt))</span>
                        } else<span class="cov0" title="0"> {
                                conn.Write([]byte("find: missing path\r\n" + prompt))
                        }</span>

                case "tail", "head":<span class="cov0" title="0">
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                filename := args[0]
                                if !strings.HasPrefix(filename, "/") </span><span class="cov0" title="0">{
                                        filename = currentDir + "/" + filename
                                }</span>
                                <span class="cov0" title="0">if content, ok := vfs.ReadFile(filename); ok </span><span class="cov0" title="0">{
                                        lines := strings.Split(content, "\n")
                                        if cmd == "tail" </span><span class="cov0" title="0">{
                                                if len(lines) &gt; 10 </span><span class="cov0" title="0">{
                                                        lines = lines[len(lines)-10:]
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                if len(lines) &gt; 10 </span><span class="cov0" title="0">{
                                                        lines = lines[:10]
                                                }</span>
                                        }
                                        <span class="cov0" title="0">conn.Write([]byte(strings.Join(lines, "\n") + "\r\n" + prompt))</span>
                                } else<span class="cov0" title="0"> {
                                        conn.Write([]byte(fmt.Sprintf("%s: %s: No such file or directory\r\n", cmd, args[0]) + prompt))
                                }</span>
                        } else<span class="cov0" title="0"> {
                                conn.Write([]byte(fmt.Sprintf("%s: missing file operand\r\n", cmd) + prompt))
                        }</span>

                case "wget", "curl":<span class="cov0" title="0">
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                url := args[0]
                                conn.Write([]byte(fmt.Sprintf("--%s--  %s\r\n", time.Now().Format("2021-12-15 10:30:15"), url)))
                                time.Sleep(300 * time.Millisecond)
                                conn.Write([]byte("Connecting to " + strings.TrimPrefix(strings.TrimPrefix(url, "http://"), "https://") + "...\r\n"))
                                time.Sleep(200 * time.Millisecond)
                                conn.Write([]byte("HTTP request sent, awaiting response... 200 OK\r\n"))
                                conn.Write([]byte("Length: 1024 (1.0K) [text/html]\r\n"))
                                conn.Write([]byte("Saving to: 'index.html'\r\n"))
                                time.Sleep(100 * time.Millisecond)
                                conn.Write([]byte("100%[======================================&gt;] 1,024      --.-K/s   in 0s\r\n"))
                                conn.Write([]byte(fmt.Sprintf("'index.html' saved [1024/1024]\r\n" + prompt)))
                        }</span> else<span class="cov0" title="0"> {
                                conn.Write([]byte(fmt.Sprintf("%s: missing URL\r\n", cmd) + prompt))
                        }</span>

                case "systemctl", "service":<span class="cov0" title="0">
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                action := args[0]
                                service := ""
                                if len(args) &gt; 1 </span><span class="cov0" title="0">{
                                        service = args[1]
                                }</span>
                                <span class="cov0" title="0">if action == "status" &amp;&amp; service != "" </span><span class="cov0" title="0">{
                                        conn.Write([]byte(fmt.Sprintf("● %s.service - %s\r\n", service, strings.Title(service)+" Service")))
                                        conn.Write([]byte("   Loaded: loaded (/etc/systemd/system/" + service + ".service; enabled; vendor preset: enabled)\r\n"))
                                        conn.Write([]byte("   Active: active (running) since Wed 2021-12-15 10:00:00 UTC; 30min ago\r\n"))
                                        conn.Write([]byte(prompt))
                                }</span> else<span class="cov0" title="0"> if action == "start" || action == "stop" || action == "restart" </span><span class="cov0" title="0">{
                                        conn.Write([]byte(fmt.Sprintf("Service %s %sed successfully\r\n", service, action) + prompt))
                                }</span> else<span class="cov0" title="0"> {
                                        conn.Write([]byte(fmt.Sprintf("Unknown action: %s\r\n", action) + prompt))
                                }</span>
                        } else<span class="cov0" title="0"> {
                                conn.Write([]byte(fmt.Sprintf("%s: missing argument\r\n", cmd) + prompt))
                        }</span>

                case "sudo":<span class="cov0" title="0">
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                conn.Write([]byte(fmt.Sprintf("[sudo] password for root: ")))
                                time.Sleep(500 * time.Millisecond)
                                conn.Write([]byte("\r\n"))
                                // Simulate command execution
                                subCmd := strings.Join(args, " ")
                                conn.Write([]byte(fmt.Sprintf("Executing: %s\r\n", subCmd) + prompt))
                        }</span> else<span class="cov0" title="0"> {
                                conn.Write([]byte("sudo: missing command\r\n" + prompt))
                        }</span>

                case "passwd":<span class="cov0" title="0">
                        conn.Write([]byte("Changing password for root.\r\n"))
                        conn.Write([]byte("Current password: "))
                        time.Sleep(1000 * time.Millisecond)
                        conn.Write([]byte("\r\n"))
                        conn.Write([]byte("New password: "))
                        time.Sleep(500 * time.Millisecond)
                        conn.Write([]byte("\r\n"))
                        conn.Write([]byte("Retype new password: "))
                        time.Sleep(500 * time.Millisecond)
                        conn.Write([]byte("\r\n"))
                        conn.Write([]byte("passwd: password updated successfully\r\n" + prompt))</span>

                case "su":<span class="cov0" title="0">
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                conn.Write([]byte("Password: "))
                                time.Sleep(500 * time.Millisecond)
                                conn.Write([]byte("\r\n"))
                                conn.Write([]byte("su: Authentication failure\r\n" + prompt))
                        }</span> else<span class="cov0" title="0"> {
                                conn.Write([]byte("su: must be run from a terminal\r\n" + prompt))
                        }</span>

                case "vi", "vim", "nano":<span class="cov0" title="0">
                        conn.Write([]byte(fmt.Sprintf("Opening %s in %s...\r\n", args[0], cmd)))
                        time.Sleep(200 * time.Millisecond)
                        conn.Write([]byte("Press 'q' to quit\r\n"))
                        // Wait for quit command
                        time.Sleep(1000 * time.Millisecond)
                        conn.Write([]byte(fmt.Sprintf("File saved: %s\r\n", args[0]) + prompt))</span>

                case "mysql":<span class="cov0" title="0">
                        conn.Write([]byte("Welcome to the MySQL monitor.  Commands end with ; or \\g.\r\n"))
                        conn.Write([]byte("Your MySQL connection id is 12345\r\n"))
                        conn.Write([]byte("Server version: 8.0.27 MySQL Community Server - GPL\r\n\r\n"))
                        conn.Write([]byte("mysql&gt; "))
                        // Wait for command
                        time.Sleep(2000 * time.Millisecond)
                        conn.Write([]byte("\r\nERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: YES)\r\n" + prompt))</span>

                case "python", "python3":<span class="cov0" title="0">
                        if len(args) &gt; 0 &amp;&amp; args[0] == "-c" </span><span class="cov0" title="0">{
                                conn.Write([]byte("Python 3.8.10 (default, Nov 26 2021, 20:14:08)\r\n"))
                                conn.Write([]byte("[GCC 9.4.0] on linux\r\n"))
                                conn.Write([]byte("Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.\r\n"))
                        }</span> else<span class="cov0" title="0"> {
                                conn.Write([]byte("Python 3.8.10 (default, Nov 26 2021, 20:14:08)\r\n"))
                                conn.Write([]byte("[GCC 9.4.0] on linux\r\n"))
                                conn.Write([]byte("Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.\r\n"))
                                conn.Write([]byte("&gt;&gt;&gt; "))
                                time.Sleep(2000 * time.Millisecond)
                                conn.Write([]byte("\r\n" + prompt))
                        }</span>

                case "clear", "reset":<span class="cov0" title="0">
                        conn.Write([]byte("\033[2J\033[H" + prompt))</span>

                default:<span class="cov0" title="0">
                        time.Sleep(50 * time.Millisecond)
                        conn.Write([]byte(fmt.Sprintf("bash: %s: command not found\r\n", cmd) + prompt))</span>
                }
        }
}

</pre>
		
		<pre class="file" id="file26" style="display: none">package logger

import (
        "time"
)

// EventType represents the type of security event
type EventType string

const (
        EventTypeTrapHit      EventType = "trap_hit"
        EventTypeCommand      EventType = "command"
        EventTypeSPAAuth      EventType = "spa_auth"
        EventTypeSPAFailed    EventType = "spa_failed"
        EventTypeStealthDrop  EventType = "stealth_drop"
        EventTypeOSMutation   EventType = "os_mutation"
        EventTypeEgressBlock  EventType = "egress_block"
        EventTypeConnection   EventType = "connection"
        EventTypeSystem      EventType = "system"
)

// SecurityEvent represents a structured security event for ELK export
type SecurityEvent struct {
        Timestamp   string                 `json:"@timestamp"`
        EventType   EventType              `json:"event_type"`
        SourceIP    string                 `json:"source_ip,omitempty"`
        DestinationIP string               `json:"destination_ip,omitempty"`
        Port        int                    `json:"port,omitempty"`
        Command     string                 `json:"command,omitempty"`
        Service     string                 `json:"service,omitempty"`
        Message     string                 `json:"message"`
        RiskLevel   string                 `json:"risk_level,omitempty"`
        Metadata    map[string]interface{} `json:"metadata,omitempty"`
}

// NewSecurityEvent creates a new security event
func NewSecurityEvent(eventType EventType, message string) *SecurityEvent <span class="cov0" title="0">{
        return &amp;SecurityEvent{
                Timestamp: time.Now().UTC().Format(time.RFC3339),
                EventType: eventType,
                Message:   message,
                Metadata:   make(map[string]interface{}),
        }
}</span>

// WithSourceIP sets the source IP
func (e *SecurityEvent) WithSourceIP(ip string) *SecurityEvent <span class="cov0" title="0">{
        e.SourceIP = ip
        return e
}</span>

// WithDestinationIP sets the destination IP
func (e *SecurityEvent) WithDestinationIP(ip string) *SecurityEvent <span class="cov0" title="0">{
        e.DestinationIP = ip
        return e
}</span>

// WithPort sets the port
func (e *SecurityEvent) WithPort(port int) *SecurityEvent <span class="cov0" title="0">{
        e.Port = port
        return e
}</span>

// WithCommand sets the command
func (e *SecurityEvent) WithCommand(cmd string) *SecurityEvent <span class="cov0" title="0">{
        e.Command = cmd
        e.RiskLevel = "HIGH"
        return e
}</span>

// WithService sets the service name
func (e *SecurityEvent) WithService(service string) *SecurityEvent <span class="cov0" title="0">{
        e.Service = service
        return e
}</span>

// WithRiskLevel sets the risk level
func (e *SecurityEvent) WithRiskLevel(level string) *SecurityEvent <span class="cov0" title="0">{
        e.RiskLevel = level
        return e
}</span>

// WithMetadata adds metadata
func (e *SecurityEvent) WithMetadata(key string, value interface{}) *SecurityEvent <span class="cov0" title="0">{
        if e.Metadata == nil </span><span class="cov0" title="0">{
                e.Metadata = make(map[string]interface{})
        }</span>
        <span class="cov0" title="0">e.Metadata[key] = value
        return e</span>
}

// ToMap converts SecurityEvent to map for ELK export
func (e *SecurityEvent) ToMap() map[string]interface{} <span class="cov0" title="0">{
        result := map[string]interface{}{
                "@timestamp": e.Timestamp,
                "event_type": string(e.EventType),
                "message":    e.Message,
        }

        if e.SourceIP != "" </span><span class="cov0" title="0">{
                result["source_ip"] = e.SourceIP
        }</span>
        <span class="cov0" title="0">if e.DestinationIP != "" </span><span class="cov0" title="0">{
                result["destination_ip"] = e.DestinationIP
        }</span>
        <span class="cov0" title="0">if e.Port &gt; 0 </span><span class="cov0" title="0">{
                result["port"] = e.Port
        }</span>
        <span class="cov0" title="0">if e.Command != "" </span><span class="cov0" title="0">{
                result["command"] = e.Command
        }</span>
        <span class="cov0" title="0">if e.Service != "" </span><span class="cov0" title="0">{
                result["service"] = e.Service
        }</span>
        <span class="cov0" title="0">if e.RiskLevel != "" </span><span class="cov0" title="0">{
                result["risk_level"] = e.RiskLevel
        }</span>
        <span class="cov0" title="0">if len(e.Metadata) &gt; 0 </span><span class="cov0" title="0">{
                result["metadata"] = e.Metadata
        }</span>

        <span class="cov0" title="0">return result</span>
}


</pre>
		
		<pre class="file" id="file27" style="display: none">package logger

import (
        "encoding/json"
        "os"
        "time"
)

// AttackLog is the structured format for attack logging
type AttackLog struct {
        Timestamp  string `json:"timestamp"`
        AttackerIP string `json:"src_ip"`
        Command    string `json:"command"`
        RiskLevel  string `json:"risk_level"`
}

// LogChannel is a channel for sending log messages
var LogChannel = make(chan string, 100)

// LogAttack writes a structured AttackLog entry to disk
func LogAttack(ip string, cmd string) <span class="cov8" title="1">{
        entry := AttackLog{
                Timestamp:  time.Now().Format(time.RFC3339),
                AttackerIP: ip,
                Command:    cmd,
                RiskLevel:  "HIGH",
        }
        if err := os.MkdirAll("logs", 0o755); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">file, err := os.OpenFile("logs/audit.json", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0o644)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">defer file.Close()
        if err := json.NewEncoder(file).Encode(entry); err != nil </span><span class="cov0" title="0">{
                _ = err
        }</span>
}

</pre>
		
		<pre class="file" id="file28" style="display: none">package logger

import (
        "fmt"
        "log"
        "strings"

        "phantom-grid/internal/config"
        "phantom-grid/internal/exporter"
)

// Manager manages log output to dashboard and/or ELK
type Manager struct {
        outputMode   config.OutputMode
        logChan      chan string
        elkExporter  *exporter.ELKExporter
        dashboardChan chan&lt;- string
}

// NewManager creates a new logger manager
func NewManager(outputMode config.OutputMode, elkConfig config.ELKConfiguration, dashboardChan chan&lt;- string) (*Manager, error) <span class="cov0" title="0">{
        mgr := &amp;Manager{
                outputMode:    outputMode,
                logChan:       make(chan string, 1000),
                dashboardChan: dashboardChan,
        }

        // Initialize ELK exporter if needed
        if outputMode == config.OutputModeELK || outputMode == config.OutputModeBoth </span><span class="cov0" title="0">{
                elkConfig.Enabled = true
                exporter, err := exporter.NewELKExporter(elkConfig)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to initialize ELK exporter: %w", err)
                }</span>
                <span class="cov0" title="0">mgr.elkExporter = exporter
                log.Printf("[SYSTEM] ELK exporter initialized: %s", strings.Join(elkConfig.Addresses, ", "))</span>
        }

        // Start log processing goroutine
        <span class="cov0" title="0">go mgr.processLogs()

        return mgr, nil</span>
}

// LogChannel returns the channel for sending log messages
func (m *Manager) LogChannel() chan&lt;- string <span class="cov0" title="0">{
        return m.logChan
}</span>

// processLogs processes logs and routes them to dashboard and/or ELK
func (m *Manager) processLogs() <span class="cov0" title="0">{
        for msg := range m.logChan </span><span class="cov0" title="0">{
                // Route to dashboard if enabled
                if m.outputMode == config.OutputModeDashboard || m.outputMode == config.OutputModeBoth </span><span class="cov0" title="0">{
                        if m.dashboardChan != nil </span><span class="cov0" title="0">{
                                select </span>{
                                case m.dashboardChan &lt;- msg:<span class="cov0" title="0"></span>
                                default:<span class="cov0" title="0"></span>
                                        // Channel full, skip (non-blocking)
                                }
                        }
                }

                // Route to ELK if enabled
                <span class="cov0" title="0">if (m.outputMode == config.OutputModeELK || m.outputMode == config.OutputModeBoth) &amp;&amp; m.elkExporter != nil </span><span class="cov0" title="0">{
                        event := m.parseLogMessage(msg)
                        if event != nil </span><span class="cov0" title="0">{
                                if err := m.elkExporter.Export(event.ToMap()); err != nil </span><span class="cov0" title="0">{
                                        log.Printf("[ELK] Failed to export event: %v", err)
                                }</span>
                        }
                }
        }
}

// parseLogMessage parses a log message and creates a SecurityEvent
func (m *Manager) parseLogMessage(msg string) *SecurityEvent <span class="cov0" title="0">{
        // Parse different log message formats
        if strings.Contains(msg, "TRAP HIT") </span><span class="cov0" title="0">{
                // Extract IP and port from message
                event := NewSecurityEvent(EventTypeTrapHit, msg)
                event.RiskLevel = "HIGH"
                return event
        }</span>

        <span class="cov0" title="0">if strings.Contains(msg, "COMMAND") </span><span class="cov0" title="0">{
                // Extract command from message
                event := NewSecurityEvent(EventTypeCommand, msg)
                event.RiskLevel = "HIGH"
                // Try to extract command
                if idx := strings.Index(msg, "COMMAND:"); idx != -1 </span><span class="cov0" title="0">{
                        cmd := strings.TrimSpace(msg[idx+8:])
                        event.Command = cmd
                }</span>
                <span class="cov0" title="0">return event</span>
        }

        <span class="cov0" title="0">if strings.Contains(msg, "[SPA] Successful authentication") </span><span class="cov0" title="0">{
                event := NewSecurityEvent(EventTypeSPAAuth, msg)
                event.RiskLevel = "INFO"
                return event
        }</span>

        <span class="cov0" title="0">if strings.Contains(msg, "[SPA] Failed authentication") </span><span class="cov0" title="0">{
                event := NewSecurityEvent(EventTypeSPAFailed, msg)
                event.RiskLevel = "MEDIUM"
                return event
        }</span>

        <span class="cov0" title="0">if strings.Contains(msg, "stealth") || strings.Contains(msg, "Stealth") </span><span class="cov0" title="0">{
                event := NewSecurityEvent(EventTypeStealthDrop, msg)
                event.RiskLevel = "MEDIUM"
                return event
        }</span>

        <span class="cov0" title="0">if strings.Contains(msg, "OS mutation") || strings.Contains(msg, "OS fingerprint") </span><span class="cov0" title="0">{
                event := NewSecurityEvent(EventTypeOSMutation, msg)
                event.RiskLevel = "LOW"
                return event
        }</span>

        <span class="cov0" title="0">if strings.Contains(msg, "egress") || strings.Contains(msg, "DLP") </span><span class="cov0" title="0">{
                event := NewSecurityEvent(EventTypeEgressBlock, msg)
                event.RiskLevel = "HIGH"
                return event
        }</span>

        <span class="cov0" title="0">if strings.Contains(msg, "Connection") || strings.Contains(msg, "connection") </span><span class="cov0" title="0">{
                event := NewSecurityEvent(EventTypeConnection, msg)
                event.RiskLevel = "LOW"
                return event
        }</span>

        // Default to system event
        <span class="cov0" title="0">event := NewSecurityEvent(EventTypeSystem, msg)
        event.RiskLevel = "INFO"
        return event</span>
}

// LogEvent logs a structured security event
func (m *Manager) LogEvent(event *SecurityEvent) <span class="cov0" title="0">{
        // Send to dashboard as formatted message
        if m.outputMode == config.OutputModeDashboard || m.outputMode == config.OutputModeBoth </span><span class="cov0" title="0">{
                if m.dashboardChan != nil </span><span class="cov0" title="0">{
                        msg := fmt.Sprintf("[%s] %s", event.EventType, event.Message)
                        if event.SourceIP != "" </span><span class="cov0" title="0">{
                                msg += fmt.Sprintf(" | IP: %s", event.SourceIP)
                        }</span>
                        <span class="cov0" title="0">if event.Command != "" </span><span class="cov0" title="0">{
                                msg += fmt.Sprintf(" | CMD: %s", event.Command)
                        }</span>
                        <span class="cov0" title="0">select </span>{
                        case m.dashboardChan &lt;- msg:<span class="cov0" title="0"></span>
                        default:<span class="cov0" title="0"></span>
                        }
                }
        }

        // Send to ELK
        <span class="cov0" title="0">if (m.outputMode == config.OutputModeELK || m.outputMode == config.OutputModeBoth) &amp;&amp; m.elkExporter != nil </span><span class="cov0" title="0">{
                if err := m.elkExporter.Export(event.ToMap()); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[ELK] Failed to export event: %v", err)
                }</span>
        }
}

// Close closes the logger manager
func (m *Manager) Close() error <span class="cov0" title="0">{
        close(m.logChan)
        if m.elkExporter != nil </span><span class="cov0" title="0">{
                return m.elkExporter.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}


</pre>
		
		<pre class="file" id="file29" style="display: none">package mirage

import (
        "math/rand"
        "time"
)

// Banner database for The Mirage effect
var (
        SSHBanners = []string{
                "SSH-2.0-OpenSSH_8.2p1 Ubuntu-4ubuntu0.5\r\n",
                "SSH-2.0-OpenSSH_7.4 Debian-10+deb9u7\r\n",
                "SSH-2.0-OpenSSH_8.0 FreeBSD-20200214\r\n",
                "SSH-2.0-OpenSSH_7.9 CentOS-7.9\r\n",
                "SSH-2.0-OpenSSH_8.1 RedHat-8.1\r\n",
                "SSH-2.0-OpenSSH_6.7p1 Debian-5+deb8u4\r\n",
                "SSH-2.0-OpenSSH_7.6p1 Ubuntu-4ubuntu0.3\r\n",
                "SSH-2.0-OpenSSH_8.4p1 Arch Linux\r\n",
        }

        HTTPBanners = []string{
                "HTTP/1.1 200 OK\r\nServer: nginx/1.18.0 (Ubuntu)\r\n\r\n",
                "HTTP/1.1 200 OK\r\nServer: Apache/2.4.41 (Debian)\r\n\r\n",
                "HTTP/1.1 200 OK\r\nServer: Microsoft-IIS/10.0\r\n\r\n",
                "HTTP/1.1 200 OK\r\nServer: nginx/1.20.1\r\n\r\n",
        }

        MySQLBanners = []string{
                "\x0a5.7.35-0ubuntu0.18.04.1\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",
                "\x0a8.0.27-0ubuntu0.20.04.1\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",
                "\x0a10.3.34-MariaDB-1:10.3.34+maria~focal\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",
        }

        RedisBanners = []string{
                "$6\r\nRedis\r\n",
                "$7\r\nRedis 6.2.6\r\n",
                "$7\r\nRedis 5.0.7\r\n",
        }

        FTPBanners = []string{
                "220 ProFTPD 1.3.6 Server (ProFTPD Default Installation) [::ffff:192.168.1.1]\r\n",
                "220 (vsFTPd 3.0.3)\r\n",
                "220 Microsoft FTP Service\r\n",
        }

        TelnetBanners = []string{
                "Welcome to Ubuntu 20.04.3 LTS (GNU/Linux 5.4.0-74-generic x86_64)\r\n\r\n* Documentation:  https://help.ubuntu.com\r\n* Management:     https://landscape.canonical.com\r\n* Support:        https://ubuntu.com/advantage\r\n\r\n  System information as of ",
                "Red Hat Enterprise Linux Server release 7.9 (Maipo)\r\nKernel 3.10.0-1160.el7.x86_64 on an x86_64\r\n\r\nlogin: ",
                "CentOS Linux 7 (Core)\r\nKernel 3.10.0-1160.el7.x86_64 on an x86_64\r\n\r\nlocalhost login: ",
                "Debian GNU/Linux 10\r\n\r\nlocalhost login: ",
        }

        ServiceTypes = []string{"ssh", "http", "mysql", "redis", "ftp", "telnet"}
)

func init() <span class="cov0" title="0">{
        rand.Seed(time.Now().UnixNano())
}</span>

// GetRandomBanner returns a random banner for the given service type
func GetRandomBanner(serviceType string) string <span class="cov0" title="0">{
        switch serviceType </span>{
        case "ssh":<span class="cov0" title="0">
                return SSHBanners[rand.Intn(len(SSHBanners))]</span>
        case "http":<span class="cov0" title="0">
                return HTTPBanners[rand.Intn(len(HTTPBanners))]</span>
        case "mysql":<span class="cov0" title="0">
                return MySQLBanners[rand.Intn(len(MySQLBanners))]</span>
        case "redis":<span class="cov0" title="0">
                return RedisBanners[rand.Intn(len(RedisBanners))]</span>
        case "ftp":<span class="cov0" title="0">
                return FTPBanners[rand.Intn(len(FTPBanners))]</span>
        case "telnet":<span class="cov0" title="0">
                return TelnetBanners[rand.Intn(len(TelnetBanners))]</span>
        default:<span class="cov0" title="0">
                return SSHBanners[rand.Intn(len(SSHBanners))]</span>
        }
}

// SelectRandomService returns a random service type
func SelectRandomService() string <span class="cov0" title="0">{
        return ServiceTypes[rand.Intn(len(ServiceTypes))]
}</span>

// SelectServiceByPort selects service type based on port for realistic deception
func SelectServiceByPort(port int) string <span class="cov0" title="0">{
        switch port </span>{
        case 80, 443, 8080, 8443, 8000, 8888:<span class="cov0" title="0">
                return "http"</span>
        case 3306, 5432, 1433, 1521:<span class="cov0" title="0">
                return "mysql"</span>
        case 6379, 11211:<span class="cov0" title="0">
                return "redis"</span>
        case 27017, 27018:<span class="cov0" title="0">
                return "mysql"</span>
        case 21:<span class="cov0" title="0">
                return "ftp"</span>
        case 23:<span class="cov0" title="0">
                return "telnet"</span>
        case 3389, 5900:<span class="cov0" title="0">
                return "ssh"</span>
        case 9200, 5601:<span class="cov0" title="0">
                return "http"</span>
        case 3000, 5000:<span class="cov0" title="0">
                return "http"</span>
        default:<span class="cov0" title="0">
                return SelectRandomService()</span>
        }
}

</pre>
		
		<pre class="file" id="file30" style="display: none">package network

import (
        "fmt"
        "log"
        "net"
        "strings"
)

// DetectInterface detects and returns the appropriate network interface
func DetectInterface(specifiedInterface string) (*net.Interface, string, error) <span class="cov0" title="0">{
        // List all interfaces for debugging
        allInterfaces, _ := net.Interfaces()
        log.Printf("[DEBUG] Available interfaces:")
        for _, iface := range allInterfaces </span><span class="cov0" title="0">{
                addrs, _ := iface.Addrs()
                isLoopback := (iface.Flags &amp; net.FlagLoopback) != 0
                log.Printf("[DEBUG]   - %s (index: %d, loopback: %v, addrs: %d)", iface.Name, iface.Index, isLoopback, len(addrs))
                for _, addr := range addrs </span><span class="cov0" title="0">{
                        log.Printf("[DEBUG]     IP: %s", addr.String())
                }</span>
        }

        <span class="cov0" title="0">if specifiedInterface != "" </span><span class="cov0" title="0">{
                return getInterfaceByName(specifiedInterface)
        }</span>

        <span class="cov0" title="0">return autoDetectInterface()</span>
}

func getInterfaceByName(name string) (*net.Interface, string, error) <span class="cov0" title="0">{
        iface, err := net.InterfaceByName(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to find interface '%s': %w", name, err)
        }</span>

        <span class="cov0" title="0">log.Printf("[*] Using user-specified interface: %s (index: %d)", name, iface.Index)
        addrs, _ := iface.Addrs()
        for _, addr := range addrs </span><span class="cov0" title="0">{
                log.Printf("[*]   IP: %s", addr.String())
        }</span>

        <span class="cov0" title="0">return iface, name, nil</span>
}

func autoDetectInterface() (*net.Interface, string, error) <span class="cov0" title="0">{
        log.Printf("[*] No interface specified, auto-detecting...")

        interfaceNames := []string{"wlx00127b2163a6", "wlan0", "ens33", "eth0", "enp0s3", "enp0s8", "enp0s9", "eth1"}
        var foundExternal bool
        var selectedIface *net.Interface
        var selectedName string

        // Try to find WiFi interface by pattern
        wifiInterfaces, _ := net.Interfaces()
        for _, candidateIface := range wifiInterfaces </span><span class="cov0" title="0">{
                if strings.HasPrefix(candidateIface.Name, "wlx") ||
                        strings.HasPrefix(candidateIface.Name, "wlan") ||
                        strings.HasPrefix(candidateIface.Name, "wlp") </span><span class="cov0" title="0">{
                        addrs, _ := candidateIface.Addrs()
                        if len(addrs) &gt; 0 </span><span class="cov0" title="0">{
                                isLoopback := (candidateIface.Flags &amp; net.FlagLoopback) != 0
                                if !isLoopback </span><span class="cov0" title="0">{
                                        ifaceCopy := candidateIface
                                        selectedIface = &amp;ifaceCopy
                                        selectedName = candidateIface.Name
                                        foundExternal = true
                                        log.Printf("[*] Found WiFi interface: %s (index: %d)", selectedName, selectedIface.Index)
                                        for _, addr := range addrs </span><span class="cov0" title="0">{
                                                log.Printf("[*]   IP: %s", addr.String())
                                        }</span>
                                        <span class="cov0" title="0">break</span>
                                }
                        }
                }
        }

        // If WiFi not found, try exact interface names
        <span class="cov0" title="0">if !foundExternal </span><span class="cov0" title="0">{
                for _, name := range interfaceNames </span><span class="cov0" title="0">{
                        iface, err := net.InterfaceByName(name)
                        if err == nil </span><span class="cov0" title="0">{
                                addrs, _ := iface.Addrs()
                                if len(addrs) &gt; 0 </span><span class="cov0" title="0">{
                                        isLoopback := (iface.Flags &amp; net.FlagLoopback) != 0
                                        if !isLoopback </span><span class="cov0" title="0">{
                                                selectedIface = iface
                                                selectedName = name
                                                foundExternal = true
                                                log.Printf("[*] Using network interface: %s (index: %d)", selectedName, selectedIface.Index)
                                                for _, addr := range addrs </span><span class="cov0" title="0">{
                                                        log.Printf("[*]   IP: %s", addr.String())
                                                }</span>
                                                <span class="cov0" title="0">break</span>
                                        } else<span class="cov0" title="0"> {
                                                log.Printf("[DEBUG] Interface %s is loopback, skipping", name)
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        log.Printf("[DEBUG] Interface %s has no IP addresses, skipping", name)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                log.Printf("[DEBUG] Interface %s not found: %v", name, err)
                        }</span>
                }
        }

        // Fallback to loopback
        <span class="cov0" title="0">if !foundExternal </span><span class="cov0" title="0">{
                iface, err := net.InterfaceByName("lo")
                if err == nil </span><span class="cov0" title="0">{
                        selectedIface = iface
                        selectedName = "lo"
                        log.Printf("[*] Using loopback interface: %s (index: %d) - for local testing only", selectedName, selectedIface.Index)
                        log.Printf("[!] WARNING: For production, attach to external interface (eth0, ens33, etc.)")
                        log.Printf("[!] WARNING: Traffic from external hosts (Kali) will NOT be captured on loopback!")
                }</span>
        }

        <span class="cov0" title="0">if selectedIface == nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("no suitable network interface found")
        }</span>

        <span class="cov0" title="0">return selectedIface, selectedName, nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package spa

import (
        "encoding/binary"
        "fmt"
        "net"
        "time"

        "phantom-grid/internal/config"
)

// Handler handles dynamic SPA packet verification in user-space
type Handler struct {
        verifier    *Verifier
        mapLoader   *MapLoader
        logChan     chan&lt;- string
        spaConfig   *config.DynamicSPAConfig
        staticToken string // Static token for legacy SPA mode (configurable)
        udpConn     *net.UDPConn
        stopChan    chan struct{}
}

// NewHandler creates a new SPA packet handler
func NewHandler(verifier *Verifier, mapLoader *MapLoader, logChan chan&lt;- string, spaConfig *config.DynamicSPAConfig, staticToken string) *Handler <span class="cov8" title="1">{
        // Use default token if not provided
        if staticToken == "" </span><span class="cov8" title="1">{
                staticToken = config.SPASecretToken
        }</span>
        <span class="cov8" title="1">return &amp;Handler{
                verifier:   verifier,
                mapLoader:  mapLoader,
                logChan:    logChan,
                spaConfig:  spaConfig,
                staticToken: staticToken,
                stopChan:   make(chan struct{}),
        }</span>
}

// Start starts the UDP listener for SPA packets
func (h *Handler) Start() error <span class="cov8" title="1">{
        addr := &amp;net.UDPAddr{
                IP:   net.IPv4zero,
                Port: int(config.SPAMagicPort),
        }

        conn, err := net.ListenUDP("udp", addr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to listen on SPA port: %w", err)
        }</span>

        <span class="cov8" title="1">h.udpConn = conn

        // Start packet handler goroutine
        go h.handlePackets()

        // Log startup information (use fmt.Printf for immediate output)
        msg := fmt.Sprintf("[SPA] User-space handler started on port %d", config.SPAMagicPort)
        fmt.Printf("%s\n", msg)
        select </span>{
        case h.logChan &lt;- msg:<span class="cov8" title="1"></span>
        default:<span class="cov0" title="0"></span>
        }
        
        <span class="cov8" title="1">if h.spaConfig != nil </span><span class="cov8" title="1">{
                msg := fmt.Sprintf("[SPA] Mode: %s", h.spaConfig.Mode)
                fmt.Printf("%s\n", msg)
                select </span>{
                case h.logChan &lt;- msg:<span class="cov8" title="1"></span>
                default:<span class="cov0" title="0"></span>
                }
        } else<span class="cov0" title="0"> {
                msg := fmt.Sprintf("[SPA] Mode: static (legacy)")
                fmt.Printf("%s\n", msg)
                select </span>{
                case h.logChan &lt;- msg:<span class="cov0" title="0"></span>
                default:<span class="cov0" title="0"></span>
                }
        }
        <span class="cov8" title="1">if h.staticToken != "" </span><span class="cov8" title="1">{
                msg := fmt.Sprintf("[SPA] Static token configured (length: %d)", len(h.staticToken))
                fmt.Printf("%s\n", msg)
                select </span>{
                case h.logChan &lt;- msg:<span class="cov8" title="1"></span>
                default:<span class="cov0" title="0"></span>
                }
        }
        <span class="cov8" title="1">readyMsg := fmt.Sprintf("[SPA] Handler ready to receive packets")
        fmt.Printf("%s\n", readyMsg)
        // Non-blocking send to log channel
        select </span>{
        case h.logChan &lt;- readyMsg:<span class="cov8" title="1"></span>
                default:<span class="cov0" title="0"></span>
                // Channel full, but we already printed to stdout
        }

        <span class="cov8" title="1">return nil</span>
}

// Stop stops the handler
func (h *Handler) Stop() error <span class="cov8" title="1">{
        close(h.stopChan)
        if h.udpConn != nil </span><span class="cov8" title="1">{
                return h.udpConn.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// handlePackets processes incoming SPA packets
func (h *Handler) handlePackets() <span class="cov8" title="1">{
        buffer := make([]byte, 1500) // Max UDP packet size
        msg := fmt.Sprintf("[SPA] Packet handler goroutine started, listening for packets...")
        fmt.Printf("%s\n", msg)
        // Non-blocking send to log channel
        select </span>{
        case h.logChan &lt;- msg:<span class="cov8" title="1"></span>
        default:<span class="cov0" title="0"></span>
                // Channel full, but we already printed to stdout
        }

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-h.stopChan:<span class="cov8" title="1">
                        msg := fmt.Sprintf("[SPA] Packet handler stopping...")
                        fmt.Printf("%s\n", msg)
                        select </span>{
                        case h.logChan &lt;- msg:<span class="cov8" title="1"></span>
                        default:<span class="cov0" title="0"></span>
                        }
                        <span class="cov8" title="1">return</span>
                default:<span class="cov8" title="1">
                        // Set read deadline to allow checking stopChan
                        h.udpConn.SetReadDeadline(time.Now().Add(1 * time.Second))
                        
                        n, clientAddr, err := h.udpConn.ReadFromUDP(buffer)
                        if err != nil </span><span class="cov8" title="1">{
                                if netErr, ok := err.(net.Error); ok &amp;&amp; netErr.Timeout() </span><span class="cov0" title="0">{
                                        // Timeout is expected, continue loop
                                        continue</span>
                                }
                                <span class="cov8" title="1">errMsg := fmt.Sprintf("[SPA] Read error: %v", err)
                                fmt.Printf("%s\n", errMsg)
                                select </span>{
                                case h.logChan &lt;- errMsg:<span class="cov8" title="1"></span>
                                default:<span class="cov0" title="0"></span>
                                }
                                <span class="cov8" title="1">continue</span>
                        }

                        // Log that we received a packet (both to log channel and stdout for debugging)
                        <span class="cov0" title="0">msg := fmt.Sprintf("[SPA] Received packet from %s (length: %d bytes)", clientAddr.IP, n)
                        fmt.Printf("%s\n", msg)
                        // Non-blocking send to log channel
                        select </span>{
                        case h.logChan &lt;- msg:<span class="cov0" title="0"></span>
                        default:<span class="cov0" title="0"></span>
                                // Channel full, but we already printed to stdout
                        }

                        // Process packet
                        <span class="cov0" title="0">go h.processPacket(buffer[:n], clientAddr.IP)</span>
                }
        }
}

// processPacket verifies and processes a single SPA packet
func (h *Handler) processPacket(packetData []byte, clientIP net.IP) <span class="cov8" title="1">{
        // Check if packet is static or dynamic
        if h.isStaticPacket(packetData) </span><span class="cov8" title="1">{
                // Legacy static token - handled by eBPF, not user-space handler
                // Return early without logging (eBPF handles static packets)
                return
        }</span>
        
        // If not static packet and not dynamic packet, log for debugging
        <span class="cov8" title="1">if len(packetData) &gt; 0 </span><span class="cov8" title="1">{
                debugLen := 8
                if len(packetData) &lt; debugLen </span><span class="cov0" title="0">{
                        debugLen = len(packetData)
                }</span>
                <span class="cov8" title="1">msg := fmt.Sprintf("[SPA] Received non-matching packet from %s (length: %d, first bytes: %x, expected token length: %d)", clientIP, len(packetData), packetData[:debugLen], len(h.staticToken))
                fmt.Printf("%s\n", msg)
                select </span>{
                case h.logChan &lt;- msg:<span class="cov8" title="1"></span>
                default:<span class="cov0" title="0"></span>
                }
        }

        // Parse dynamic packet
        <span class="cov8" title="1">packet, err := ParseSPAPacket(packetData)
        if err != nil </span><span class="cov8" title="1">{
                errMsg := fmt.Sprintf("[SPA] Failed to parse packet from %s: %v", clientIP, err)
                fmt.Printf("%s\n", errMsg)
                select </span>{
                case h.logChan &lt;- errMsg:<span class="cov8" title="1"></span>
                default:<span class="cov0" title="0"></span>
                }
                <span class="cov8" title="1">return</span>
        }

        // Verify packet
        <span class="cov8" title="1">valid, err := h.verifier.VerifyPacket(packetData)
        if !valid </span><span class="cov8" title="1">{
                errMsg := fmt.Sprintf("[SPA] Invalid packet from %s: %v", clientIP, err)
                fmt.Printf("%s\n", errMsg)
                select </span>{
                case h.logChan &lt;- errMsg:<span class="cov8" title="1"></span>
                default:<span class="cov0" title="0"></span>
                }
                <span class="cov8" title="1">return</span>
        }

        // Whitelist IP
        <span class="cov8" title="1">if err := h.mapLoader.WhitelistIP(clientIP, h.spaConfig.ReplayWindowSeconds); err != nil </span><span class="cov8" title="1">{
                errMsg := fmt.Sprintf("[SPA] Failed to whitelist IP %s: %v", clientIP, err)
                fmt.Printf("%s\n", errMsg)
                select </span>{
                case h.logChan &lt;- errMsg:<span class="cov8" title="1"></span>
                default:<span class="cov0" title="0"></span>
                }
                <span class="cov8" title="1">return</span>
        }

        <span class="cov0" title="0">successMsg := fmt.Sprintf("[SPA] Successfully authenticated and whitelisted IP: %s", clientIP)
        fmt.Printf("%s\n", successMsg)
        select </span>{
        case h.logChan &lt;- successMsg:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0"></span>
        }
        
        <span class="cov0" title="0">totpMsg := fmt.Sprintf("[SPA] TOTP: %d, Timestamp: %d", packet.TOTP, packet.Timestamp)
        fmt.Printf("%s\n", totpMsg)
        select </span>{
        case h.logChan &lt;- totpMsg:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0"></span>
        }
}

// isStaticPacket checks if packet is legacy static token
func (h *Handler) isStaticPacket(data []byte) bool <span class="cov8" title="1">{
        // Static token is ASCII string, dynamic packet starts with version byte (1)
        staticTokenBytes := []byte(h.staticToken)
        
        // Check length first
        if len(data) != len(staticTokenBytes) </span><span class="cov8" title="1">{
                return false
        }</span>
        
        // Check if it's a dynamic packet (starts with version byte 1)
        <span class="cov8" title="1">if len(data) &gt; 0 &amp;&amp; data[0] == 1 </span><span class="cov0" title="0">{
                return false
        }</span>
        
        // Compare bytes
        <span class="cov8" title="1">for i := 0; i &lt; len(data); i++ </span><span class="cov8" title="1">{
                if data[i] != staticTokenBytes[i] </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// GetClientIPFromPacket extracts client IP from packet (for logging)
func GetClientIPFromPacket(packetData []byte) (net.IP, error) <span class="cov0" title="0">{
        // This is a helper function - in practice, IP comes from UDP connection
        // This is just for demonstration
        if len(packetData) &lt; 14 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("packet too short")
        }</span>
        
        // Extract timestamp to verify packet structure
        <span class="cov0" title="0">timestamp := int64(binary.BigEndian.Uint64(packetData[2:10]))
        _ = timestamp // Use timestamp for validation
        
        return nil, fmt.Errorf("IP must come from UDP connection")</span>
}

</pre>
		
		<pre class="file" id="file32" style="display: none">package spa

import (
        "fmt"
        "time"
)

// SPAStatsProvider interface for accessing SPA statistics
type SPAStatsProvider interface {
        GetSpaAuthSuccess() interface {
                Lookup(key uint32, value *uint64) error
        }
        GetSpaAuthFailed() interface {
                Lookup(key uint32, value *uint64) error
        }
}

// Manager manages SPA whitelist monitoring
type Manager struct {
        statsProvider     SPAStatsProvider
        logChan           chan&lt;- string
        whitelistDuration int
}

// NewManager creates a new SPA manager
func NewManager(statsProvider SPAStatsProvider, logChan chan&lt;- string, whitelistDuration int) *Manager <span class="cov0" title="0">{
        return &amp;Manager{
                statsProvider:     statsProvider,
                logChan:           logChan,
                whitelistDuration: whitelistDuration,
        }
}</span>

// Start begins monitoring SPA statistics
func (m *Manager) Start() <span class="cov0" title="0">{
        ticker := time.NewTicker(2 * time.Second)
        var lastSuccessCount uint64 = 0
        var lastFailedCount uint64 = 0

        for range ticker.C </span><span class="cov0" title="0">{
                var key uint32 = 0
                var successVal uint64
                if err := m.statsProvider.GetSpaAuthSuccess().Lookup(key, &amp;successVal); err == nil </span><span class="cov0" title="0">{
                        if successVal &gt; lastSuccessCount </span><span class="cov0" title="0">{
                                m.logChan &lt;- fmt.Sprintf("[SPA] Successful authentication! (Total: %d)", successVal)
                                m.logChan &lt;- fmt.Sprintf("[SPA] IP whitelisted for %d seconds (LRU map auto-expiry)", m.whitelistDuration)
                                lastSuccessCount = successVal
                        }</span>
                }

                <span class="cov0" title="0">var failedVal uint64
                if err := m.statsProvider.GetSpaAuthFailed().Lookup(key, &amp;failedVal); err == nil </span><span class="cov0" title="0">{
                        if failedVal &gt; lastFailedCount </span><span class="cov0" title="0">{
                                m.logChan &lt;- fmt.Sprintf("[SPA] Failed authentication attempt (Total: %d)", failedVal)
                                lastFailedCount = failedVal
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package spa

import (
        "encoding/binary"
        "fmt"
        "io"
        "net"
        "os"
        "strconv"
        "strings"

        "github.com/cilium/ebpf"

        "phantom-grid/internal/config"
)

// MapLoader loads SPA configuration into BPF maps
type MapLoader struct {
        whitelistMap    *ebpf.Map
        replayMap       *ebpf.Map
        totpSecretMap   *ebpf.Map
        hmacSecretMap   *ebpf.Map
        configMap       *ebpf.Map
}

// NewMapLoader creates a new SPA map loader
// Note: Maps must be from the dynamic SPA eBPF program
func NewMapLoader(whitelistMap, replayMap, totpSecretMap, hmacSecretMap, configMap *ebpf.Map) *MapLoader <span class="cov8" title="1">{
        return &amp;MapLoader{
                whitelistMap:  whitelistMap,
                replayMap:     replayMap,
                totpSecretMap: totpSecretMap,
                hmacSecretMap: hmacSecretMap,
                configMap:     configMap,
        }
}</span>

// LoadConfiguration loads SPA configuration into BPF maps
func (ml *MapLoader) LoadConfiguration(spaConfig *config.DynamicSPAConfig) error <span class="cov0" title="0">{
        if ml.configMap == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("config map not available")
        }</span>

        // Load TOTP secret
        <span class="cov0" title="0">if ml.totpSecretMap != nil &amp;&amp; len(spaConfig.TOTPSecret) &gt; 0 </span><span class="cov0" title="0">{
                if err := ml.loadTOTPSecret(spaConfig.TOTPSecret); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to load TOTP secret: %w", err)
                }</span>
        }

        // Load HMAC secret (for dynamic mode)
        <span class="cov0" title="0">if ml.hmacSecretMap != nil &amp;&amp; len(spaConfig.HMACSecret) &gt; 0 </span><span class="cov0" title="0">{
                if err := ml.loadHMACSecret(spaConfig.HMACSecret); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to load HMAC secret: %w", err)
                }</span>
        }

        // Load configuration values
        <span class="cov0" title="0">configValues := map[uint32]uint32{
                0: uint32(spaConfig.TOTPTimeStep),    // TOTP time step
                1: uint32(spaConfig.TOTPTolerance),  // TOTP tolerance
                2: uint32(spaConfig.ReplayWindowSeconds), // Replay window
                3: uint32(ml.getSPAModeValue(spaConfig.Mode)), // SPA mode
        }

        for key, value := range configValues </span><span class="cov0" title="0">{
                if err := ml.configMap.Put(key, value); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set config key %d: %w", key, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// WhitelistIP adds an IP address to the whitelist
func (ml *MapLoader) WhitelistIP(ip net.IP, durationSeconds int) error <span class="cov8" title="1">{
        if ml.whitelistMap == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("whitelist map not available")
        }</span>

        // Convert IP to network byte order
        <span class="cov0" title="0">ipv4 := ip.To4()
        if ipv4 == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid IPv4 address: %s", ip.String())
        }</span>

        <span class="cov0" title="0">ipUint32 := binary.BigEndian.Uint32(ipv4)

        // Calculate absolute expiry timestamp (nanoseconds since boot)
        // eBPF uses bpf_ktime_get_ns() which returns nanoseconds since system boot
        // We need to estimate the current boot time to calculate expiry correctly
        
        // Read /proc/uptime to get system uptime in seconds
        uptimeSeconds, err := getUptimeSeconds()
        if err != nil </span><span class="cov0" title="0">{
                // Fallback: use a large base time if we can't read uptime
                // This ensures expiry is in the future, but may cause issues with expiration
                baseTime := uint64(1000000000000000000) // 10^18 nanoseconds
                durationNs := uint64(durationSeconds) * 1000000000
                expiry := baseTime + durationNs
                return ml.whitelistMap.Put(ipUint32, expiry)
        }</span>
        
        // Convert uptime to nanoseconds and add duration
        <span class="cov0" title="0">uptimeNs := uint64(uptimeSeconds * 1e9)
        durationNs := uint64(durationSeconds) * 1000000000
        expiry := uptimeNs + durationNs
        
        // Add a small buffer (1 second) to account for timing differences
        expiry += 1000000000

        return ml.whitelistMap.Put(ipUint32, expiry)</span>
}

// getUptimeSeconds reads system uptime from /proc/uptime
func getUptimeSeconds() (float64, error) <span class="cov0" title="0">{
        file, err := os.Open("/proc/uptime")
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        data, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // /proc/uptime format: "uptime_seconds idle_seconds"
        <span class="cov0" title="0">fields := strings.Fields(string(data))
        if len(fields) == 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid /proc/uptime format")
        }</span>

        <span class="cov0" title="0">uptime, err := strconv.ParseFloat(fields[0], 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return uptime, nil</span>
}

// RemoveWhitelistIP removes an IP from the whitelist
func (ml *MapLoader) RemoveWhitelistIP(ip net.IP) error <span class="cov0" title="0">{
        if ml.whitelistMap == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("whitelist map not available")
        }</span>

        <span class="cov0" title="0">ipv4 := ip.To4()
        if ipv4 == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid IPv4 address: %s", ip.String())
        }</span>

        <span class="cov0" title="0">ipUint32 := binary.BigEndian.Uint32(ipv4)
        return ml.whitelistMap.Delete(ipUint32)</span>
}

// loadTOTPSecret loads TOTP secret into BPF map
func (ml *MapLoader) loadTOTPSecret(secret []byte) error <span class="cov0" title="0">{
        if len(secret) &gt; 32 </span><span class="cov0" title="0">{
                return fmt.Errorf("TOTP secret too long: %d bytes (max 32)", len(secret))
        }</span>

        // Load secret byte by byte into array map
        <span class="cov0" title="0">for i := 0; i &lt; len(secret) &amp;&amp; i &lt; 32; i++ </span><span class="cov0" title="0">{
                key := uint32(i)
                value := secret[i]
                if err := ml.totpSecretMap.Put(key, value); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set TOTP secret byte %d: %w", i, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// loadHMACSecret loads HMAC secret into BPF map
func (ml *MapLoader) loadHMACSecret(secret []byte) error <span class="cov0" title="0">{
        if len(secret) &gt; 32 </span><span class="cov0" title="0">{
                return fmt.Errorf("HMAC secret too long: %d bytes (max 32)", len(secret))
        }</span>

        // Load secret byte by byte into array map
        <span class="cov0" title="0">for i := 0; i &lt; len(secret) &amp;&amp; i &lt; 32; i++ </span><span class="cov0" title="0">{
                key := uint32(i)
                value := secret[i]
                if err := ml.hmacSecretMap.Put(key, value); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set HMAC secret byte %d: %w", i, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// getSPAModeValue converts SPAMode to uint32 for BPF map
func (ml *MapLoader) getSPAModeValue(mode config.SPAMode) uint32 <span class="cov8" title="1">{
        switch mode </span>{
        case config.SPAModeStatic:<span class="cov8" title="1">
                return 0</span>
        case config.SPAModeDynamic:<span class="cov8" title="1">
                return 1</span>
        case config.SPAModeAsymmetric:<span class="cov8" title="1">
                return 2</span>
        default:<span class="cov0" title="0">
                return 0</span> // Default to static
        }
}

</pre>
		
		<pre class="file" id="file34" style="display: none">package spa

import (
        "crypto/ed25519"
        "crypto/hmac"
        "crypto/rand"
        "crypto/sha256"
        "encoding/binary"
        "fmt"
        "time"
)

// SPAPacket represents a dynamic SPA packet
type SPAPacket struct {
        Version    uint8  // Protocol version (1 byte)
        Mode       uint8  // SPA mode: 0=static, 1=dynamic, 2=asymmetric (1 byte)
        Timestamp  int64  // Unix timestamp (8 bytes)
        TOTP       uint32 // TOTP nonce (4 bytes)
        Signature  []byte // Ed25519 signature (64 bytes) or HMAC (32 bytes)
        RandomData []byte // Random padding for obfuscation (variable)
}

// Packet sizes
const (
        SPAPacketHeaderSize = 14 // Version(1) + Mode(1) + Timestamp(8) + TOTP(4)
        Ed25519SignatureSize = 64
        HMACSignatureSize   = 32
        MinRandomPadding     = 16
        MaxRandomPadding     = 64
)

// CreateAsymmetricPacket creates an Ed25519-signed SPA packet
func CreateAsymmetricPacket(privateKey ed25519.PrivateKey, totpSecret []byte, timeStep int, enableObfuscation bool) ([]byte, error) <span class="cov8" title="1">{
        // Generate TOTP
        totp := GenerateTOTP(totpSecret, timeStep)
        timestamp := time.Now().Unix()

        // Create packet header
        packet := make([]byte, SPAPacketHeaderSize)
        packet[0] = 1 // Version 1
        packet[1] = 2 // Mode: Asymmetric
        binary.BigEndian.PutUint64(packet[2:10], uint64(timestamp))
        binary.BigEndian.PutUint32(packet[10:14], totp)

        // Add random padding for obfuscation
        var paddingSize int
        if enableObfuscation </span><span class="cov8" title="1">{
                // Generate random padding size
                randBytes := make([]byte, 1)
                rand.Read(randBytes)
                paddingSize = MinRandomPadding + int(randBytes[0])%(MaxRandomPadding-MinRandomPadding+1)
        }</span> else<span class="cov0" title="0"> {
                paddingSize = 0
        }</span>

        <span class="cov8" title="1">if paddingSize &gt; 0 </span><span class="cov8" title="1">{
                padding := make([]byte, paddingSize)
                if _, err := rand.Read(padding); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">packet = append(packet, padding...)</span>
        }

        // Sign the packet (header + padding)
        <span class="cov8" title="1">signature := ed25519.Sign(privateKey, packet)

        // Append signature
        packet = append(packet, signature...)

        return packet, nil</span>
}

// CreateDynamicPacket creates an HMAC-signed SPA packet
func CreateDynamicPacket(hmacSecret []byte, totpSecret []byte, timeStep int, enableObfuscation bool) ([]byte, error) <span class="cov8" title="1">{
        // Generate TOTP
        totp := GenerateTOTP(totpSecret, timeStep)
        timestamp := time.Now().Unix()

        // Create packet header
        packet := make([]byte, SPAPacketHeaderSize)
        packet[0] = 1 // Version 1
        packet[1] = 1 // Mode: Dynamic (HMAC)
        binary.BigEndian.PutUint64(packet[2:10], uint64(timestamp))
        binary.BigEndian.PutUint32(packet[10:14], totp)

        // Add random padding for obfuscation
        var paddingSize int
        if enableObfuscation </span><span class="cov8" title="1">{
                // Generate random padding size
                randBytes := make([]byte, 1)
                rand.Read(randBytes)
                paddingSize = MinRandomPadding + int(randBytes[0])%(MaxRandomPadding-MinRandomPadding+1)
        }</span> else<span class="cov0" title="0"> {
                paddingSize = 0
        }</span>

        <span class="cov8" title="1">if paddingSize &gt; 0 </span><span class="cov8" title="1">{
                padding := make([]byte, paddingSize)
                if _, err := rand.Read(padding); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">packet = append(packet, padding...)</span>
        }

        // Compute HMAC-SHA256
        <span class="cov8" title="1">mac := hmac.New(sha256.New, hmacSecret)
        mac.Write(packet)
        hmacValue := mac.Sum(nil)

        // Append HMAC
        packet = append(packet, hmacValue...)

        return packet, nil</span>
}

// ParseSPAPacket parses a received SPA packet
func ParseSPAPacket(data []byte) (*SPAPacket, error) <span class="cov8" title="1">{
        if len(data) &lt; SPAPacketHeaderSize </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("packet too short: %d bytes", len(data))
        }</span>

        <span class="cov8" title="1">packet := &amp;SPAPacket{
                Version: data[0],
                Mode:    data[1],
        }

        packet.Timestamp = int64(binary.BigEndian.Uint64(data[2:10]))
        packet.TOTP = binary.BigEndian.Uint32(data[10:14])

        // Determine signature size based on mode
        var signatureSize int
        switch packet.Mode </span>{
        case 1:<span class="cov8" title="1"> // Dynamic (HMAC)
                signatureSize = HMACSignatureSize</span>
        case 2:<span class="cov8" title="1"> // Asymmetric (Ed25519)
                signatureSize = Ed25519SignatureSize</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("unknown SPA mode: %d", packet.Mode)</span>
        }

        // Extract signature and padding
        <span class="cov8" title="1">if len(data) &lt; SPAPacketHeaderSize+signatureSize </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("packet too short for signature: %d bytes", len(data))
        }</span>

        // Padding is between header and signature
        <span class="cov8" title="1">paddingSize := len(data) - SPAPacketHeaderSize - signatureSize
        if paddingSize &gt; 0 </span><span class="cov8" title="1">{
                packet.RandomData = data[SPAPacketHeaderSize : SPAPacketHeaderSize+paddingSize]
        }</span>

        <span class="cov8" title="1">packet.Signature = data[len(data)-signatureSize:]

        return packet, nil</span>
}

// VerifyAsymmetricPacket verifies Ed25519 signature
func VerifyAsymmetricPacket(publicKey ed25519.PublicKey, packet *SPAPacket, packetData []byte) bool <span class="cov8" title="1">{
        // Reconstruct signed data (header + padding, without signature)
        signedData := packetData[:len(packetData)-len(packet.Signature)]

        return ed25519.Verify(publicKey, signedData, packet.Signature)
}</span>

// VerifyDynamicPacket verifies HMAC signature
func VerifyDynamicPacket(hmacSecret []byte, packet *SPAPacket, packetData []byte) bool <span class="cov8" title="1">{
        // Reconstruct signed data (header + padding, without signature)
        signedData := packetData[:len(packetData)-len(packet.Signature)]

        mac := hmac.New(sha256.New, hmacSecret)
        mac.Write(signedData)
        expectedHMAC := mac.Sum(nil)
        return hmac.Equal(expectedHMAC, packet.Signature)
}</span>

</pre>
		
		<pre class="file" id="file35" style="display: none">package spa

import (
        "crypto/hmac"
        "crypto/sha1"
        "encoding/binary"
        "time"
)

// TOTP generates a Time-based One-Time Password
func TOTP(secret []byte, timeStep int, timestamp int64) uint32 <span class="cov8" title="1">{
        // Calculate time counter
        counter := uint64(timestamp / int64(timeStep))

        // HMAC-SHA1
        mac := hmac.New(sha1.New, secret)
        binary.Write(mac, binary.BigEndian, counter)
        hash := mac.Sum(nil)

        // Dynamic truncation (RFC 4226)
        offset := hash[19] &amp; 0x0f
        code := binary.BigEndian.Uint32(hash[offset:offset+4]) &amp; 0x7fffffff

        // Return 6-digit code
        return code % 1000000
}</span>

// GenerateTOTP generates TOTP for current time
func GenerateTOTP(secret []byte, timeStep int) uint32 <span class="cov8" title="1">{
        return TOTP(secret, timeStep, time.Now().Unix())
}</span>

// ValidateTOTP validates TOTP with tolerance
func ValidateTOTP(secret []byte, timeStep, tolerance int, receivedTOTP uint32) bool <span class="cov8" title="1">{
        currentTime := time.Now().Unix()
        currentStep := currentTime / int64(timeStep)

        // Check current step and ±tolerance steps
        for i := -tolerance; i &lt;= tolerance; i++ </span><span class="cov8" title="1">{
                step := currentStep + int64(i)
                expectedTOTP := TOTP(secret, timeStep, step*int64(timeStep))
                if expectedTOTP == receivedTOTP </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// GetTOTPTimeWindow returns the time window for a given TOTP
func GetTOTPTimeWindow(timeStep int, timestamp int64) (start, end int64) <span class="cov0" title="0">{
        step := timestamp / int64(timeStep)
        start = step * int64(timeStep)
        end = start + int64(timeStep)
        return start, end
}</span>

</pre>
		
		<pre class="file" id="file36" style="display: none">package spa

import (
        "fmt"
        "time"

        "phantom-grid/internal/config"
)

// Verifier verifies dynamic SPA packets
type Verifier struct {
        spaConfig *config.DynamicSPAConfig
}

// NewVerifier creates a new SPA packet verifier
func NewVerifier(spaConfig *config.DynamicSPAConfig) *Verifier <span class="cov8" title="1">{
        return &amp;Verifier{
                spaConfig: spaConfig,
        }
}</span>

// VerifyPacket verifies a received SPA packet
func (v *Verifier) VerifyPacket(packetData []byte) (bool, error) <span class="cov8" title="1">{
        // Parse packet
        packet, err := ParseSPAPacket(packetData)
        if err != nil </span><span class="cov8" title="1">{
                return false, fmt.Errorf("failed to parse packet: %w", err)
        }</span>

        // Check version
        <span class="cov8" title="1">if packet.Version != 1 </span><span class="cov0" title="0">{
                return false, fmt.Errorf("unsupported packet version: %d", packet.Version)
        }</span>

        // Validate timestamp (prevent old packets)
        <span class="cov8" title="1">currentTime := time.Now().Unix()
        timeDiff := currentTime - packet.Timestamp
        if timeDiff &lt; 0 </span><span class="cov0" title="0">{
                timeDiff = -timeDiff
        }</span>

        // Allow ±5 minutes for clock skew
        <span class="cov8" title="1">maxTimeDiff := int64(300) // 5 minutes
        if timeDiff &gt; maxTimeDiff </span><span class="cov8" title="1">{
                return false, fmt.Errorf("packet timestamp too old or too far in future: diff=%d seconds", timeDiff)
        }</span>

        // Validate TOTP
        <span class="cov8" title="1">validTOTP := ValidateTOTP(
                v.spaConfig.TOTPSecret,
                v.spaConfig.TOTPTimeStep,
                v.spaConfig.TOTPTolerance,
                packet.TOTP,
        )

        if !validTOTP </span><span class="cov8" title="1">{
                return false, fmt.Errorf("invalid TOTP")
        }</span>

        // Verify signature based on mode
        <span class="cov8" title="1">switch v.spaConfig.Mode </span>{
        case config.SPAModeAsymmetric:<span class="cov8" title="1">
                if len(v.spaConfig.PublicKey) == 0 </span><span class="cov8" title="1">{
                        return false, fmt.Errorf("public key not configured")
                }</span>
                <span class="cov8" title="1">valid := VerifyAsymmetricPacket(v.spaConfig.PublicKey, packet, packetData)
                if !valid </span><span class="cov8" title="1">{
                        return false, fmt.Errorf("invalid Ed25519 signature")
                }</span>

        case config.SPAModeDynamic:<span class="cov8" title="1">
                if len(v.spaConfig.HMACSecret) == 0 </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("HMAC secret not configured")
                }</span>
                <span class="cov8" title="1">valid := VerifyDynamicPacket(v.spaConfig.HMACSecret, packet, packetData)
                if !valid </span><span class="cov8" title="1">{
                        return false, fmt.Errorf("invalid HMAC signature")
                }</span>

        default:<span class="cov0" title="0">
                return false, fmt.Errorf("unsupported SPA mode: %s", v.spaConfig.Mode)</span>
        }

        <span class="cov8" title="1">return true, nil</span>
}

// VerifyTOTPOnly verifies only the TOTP (for quick checks)
func (v *Verifier) VerifyTOTPOnly(totp uint32) bool <span class="cov8" title="1">{
        return ValidateTOTP(
                v.spaConfig.TOTPSecret,
                v.spaConfig.TOTPTimeStep,
                v.spaConfig.TOTPTolerance,
                totp,
        )
}</span>

</pre>
		
		<pre class="file" id="file37" style="display: none">package spa

import "github.com/cilium/ebpf"

// MapWrapper wraps ebpf.Map to implement the specific Lookup signature
type MapWrapper struct {
        Map *ebpf.Map
}

// Lookup implements the specific Lookup signature required by SPAStatsProvider
func (w *MapWrapper) Lookup(key uint32, value *uint64) error <span class="cov0" title="0">{
        return w.Map.Lookup(key, value)
}</span>

// PhantomObjectsWrapper wraps PhantomObjects to implement SPAStatsProvider
// This is a workaround since PhantomObjects is generated in cmd/agent
type PhantomObjectsWrapper struct {
        SpaAuthSuccessMap *MapWrapper
        SpaAuthFailedMap  *MapWrapper
}

// GetSpaAuthSuccess returns the SPA auth success map
func (w *PhantomObjectsWrapper) GetSpaAuthSuccess() interface{ Lookup(key uint32, value *uint64) error } <span class="cov0" title="0">{
        return w.SpaAuthSuccessMap
}</span>

// GetSpaAuthFailed returns the SPA auth failed map
func (w *PhantomObjectsWrapper) GetSpaAuthFailed() interface{ Lookup(key uint32, value *uint64) error } <span class="cov0" title="0">{
        return w.SpaAuthFailedMap
}</span>

// NewWrapper creates a wrapper for PhantomObjects
func NewWrapper(successMap, failedMap *ebpf.Map) SPAStatsProvider <span class="cov0" title="0">{
        return &amp;PhantomObjectsWrapper{
                SpaAuthSuccessMap: &amp;MapWrapper{Map: successMap},
                SpaAuthFailedMap:  &amp;MapWrapper{Map: failedMap},
        }
}</span>

</pre>
		
		<pre class="file" id="file38" style="display: none">package spa

import (
        "fmt"
        "net"
        "time"

        "phantom-grid/internal/config"
)

// Client represents an SPA client
type Client struct {
        ServerIP   string
        StaticToken string // Static token for legacy SPA mode
}

// NewClient creates a new SPA client
func NewClient(serverIP string) *Client <span class="cov8" title="1">{
        return &amp;Client{
                ServerIP:   serverIP,
                StaticToken: config.SPASecretToken, // Default token
        }
}</span>

// NewClientWithToken creates a new SPA client with custom static token
func NewClientWithToken(serverIP string, token string) *Client <span class="cov0" title="0">{
        if token == "" </span><span class="cov0" title="0">{
                token = config.SPASecretToken
        }</span>
        <span class="cov0" title="0">return &amp;Client{
                ServerIP:   serverIP,
                StaticToken: token,
        }</span>
}

// SendMagicPacket sends the SPA Magic Packet to whitelist the client's IP
func (c *Client) SendMagicPacket() error <span class="cov8" title="1">{
        addr := net.JoinHostPort(c.ServerIP, fmt.Sprintf("%d", config.SPAMagicPort))
        conn, err := net.Dial("udp", addr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create UDP connection: %w", err)
        }</span>
        <span class="cov8" title="1">defer conn.Close()

        tokenBytes := []byte(c.StaticToken)
        _, err = conn.Write(tokenBytes)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send Magic Packet: %w", err)
        }</span>

        <span class="cov8" title="1">time.Sleep(100 * time.Millisecond)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package spa

import (
        "crypto/ed25519"
        "fmt"
        "net"
        "time"

        "phantom-grid/internal/config"
        "phantom-grid/internal/spa"
)

// DynamicClient represents a dynamic SPA client with Ed25519/HMAC support
type DynamicClient struct {
        ServerIP        string
        PrivateKey      ed25519.PrivateKey // For asymmetric mode
        HMACSecret      []byte             // For dynamic mode
        TOTPSecret      []byte             // Shared TOTP secret
        SPAConfig       *config.DynamicSPAConfig
}

// NewDynamicClient creates a new dynamic SPA client
func NewDynamicClient(serverIP string, spaConfig *config.DynamicSPAConfig) (*DynamicClient, error) <span class="cov8" title="1">{
        client := &amp;DynamicClient{
                ServerIP:  serverIP,
                SPAConfig: spaConfig,
        }

        // Set secrets based on mode
        switch spaConfig.Mode </span>{
        case config.SPAModeAsymmetric:<span class="cov8" title="1">
                if len(spaConfig.PrivateKey) == 0 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("private key required for asymmetric mode")
                }</span>
                <span class="cov8" title="1">client.PrivateKey = spaConfig.PrivateKey
                client.TOTPSecret = spaConfig.TOTPSecret</span>

        case config.SPAModeDynamic:<span class="cov8" title="1">
                if len(spaConfig.HMACSecret) == 0 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("HMAC secret required for dynamic mode")
                }</span>
                <span class="cov8" title="1">client.HMACSecret = spaConfig.HMACSecret
                client.TOTPSecret = spaConfig.TOTPSecret</span>

        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("unsupported SPA mode: %s", spaConfig.Mode)</span>
        }

        <span class="cov8" title="1">return client, nil</span>
}

// SendMagicPacket sends a dynamic SPA packet
func (c *DynamicClient) SendMagicPacket() error <span class="cov8" title="1">{
        var addr string
        // Check if ServerIP already contains a port
        if _, _, err := net.SplitHostPort(c.ServerIP); err == nil </span><span class="cov8" title="1">{
                // ServerIP already has a port, use it directly
                addr = c.ServerIP
        }</span> else<span class="cov0" title="0"> {
                // ServerIP is just an IP/hostname, append default port
                addr = net.JoinHostPort(c.ServerIP, fmt.Sprintf("%d", config.SPAMagicPort))
        }</span>
        <span class="cov8" title="1">conn, err := net.Dial("udp", addr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create UDP connection: %w", err)
        }</span>
        <span class="cov8" title="1">defer conn.Close()

        var packetData []byte
        var createErr error
        switch c.SPAConfig.Mode </span>{
        case config.SPAModeAsymmetric:<span class="cov8" title="1">
                packetData, createErr = spa.CreateAsymmetricPacket(
                        c.PrivateKey,
                        c.TOTPSecret,
                        c.SPAConfig.TOTPTimeStep,
                        c.SPAConfig.EnableObfuscation,
                )
                if createErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create asymmetric packet: %w", createErr)
                }</span>

        case config.SPAModeDynamic:<span class="cov8" title="1">
                packetData, createErr = spa.CreateDynamicPacket(
                        c.HMACSecret,
                        c.TOTPSecret,
                        c.SPAConfig.TOTPTimeStep,
                        c.SPAConfig.EnableObfuscation,
                )
                if createErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create dynamic packet: %w", createErr)
                }</span>

        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported SPA mode: %s", c.SPAConfig.Mode)</span>
        }

        <span class="cov8" title="1">_, err = conn.Write(packetData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send Magic Packet: %w", err)
        }</span>

        <span class="cov8" title="1">time.Sleep(100 * time.Millisecond)
        return nil</span>
}

</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
